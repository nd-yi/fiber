{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "调度构建fiber树",
  "steps": [
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "使用这个方法去调用一个任务（包括同步和异步）",
      "line": 674,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/scheduler/src/Scheduler.js",
      "description": "Schedule-1: Shdule暴露的入口  一般转换为别名scheduleCallback 被调用， 返回task的信息",
      "line": 283,
      "selection": {
        "start": {
          "line": 320,
          "character": 7
        },
        "end": {
          "line": 320,
          "character": 14
        }
      },
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/* eslint-disable no-var */\r\n\r\nimport {\r\n  enableSchedulerDebugging,\r\n  enableProfiling,\r\n} from './SchedulerFeatureFlags';\r\nimport {\r\n  requestHostCallback,\r\n  requestHostTimeout,\r\n  cancelHostTimeout,\r\n  shouldYieldToHost,\r\n  getCurrentTime,\r\n  forceFrameRate,\r\n  requestPaint,\r\n} from './SchedulerHostConfig';\r\nimport {push, pop, peek} from './SchedulerMinHeap';\r\n\r\n// TODO: Use symbols?\r\nimport {\r\n  ImmediatePriority,\r\n  UserBlockingPriority,\r\n  NormalPriority,\r\n  LowPriority,\r\n  IdlePriority,\r\n} from './SchedulerPriorities';\r\nimport {\r\n  markTaskRun,\r\n  markTaskYield,\r\n  markTaskCompleted,\r\n  markTaskCanceled,\r\n  markTaskErrored,\r\n  markSchedulerSuspended,\r\n  markSchedulerUnsuspended,\r\n  markTaskStart,\r\n  stopLoggingProfilingEvents,\r\n  startLoggingProfilingEvents,\r\n} from './SchedulerProfiling';\r\n\r\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n// Math.pow(2, 30) - 1\r\n// 0b111111111111111111111111111111\r\nvar maxSigned31BitInt = 1073741823;\r\n\r\n// Times out immediately\r\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n// Eventually times out\r\nvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\r\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\r\nvar LOW_PRIORITY_TIMEOUT = 10000;\r\n// Never times out\r\nvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\r\n\r\n// Tasks are stored on a min heap\r\nvar taskQueue = [];\r\nvar timerQueue = [];\r\n\r\n// Incrementing id counter. Used to maintain insertion order.\r\nvar taskIdCounter = 1;\r\n\r\n// Pausing the scheduler is useful for debugging.\r\nvar isSchedulerPaused = false;\r\n\r\nvar currentTask = null;\r\nvar currentPriorityLevel = NormalPriority;\r\n\r\n// This is set while performing work, to prevent re-entrancy.\r\nvar isPerformingWork = false;\r\n\r\nvar isHostCallbackScheduled = false;\r\nvar isHostTimeoutScheduled = false;\r\n\r\nfunction advanceTimers(currentTime) {\r\n  // Check for tasks that are no longer delayed and add them to the queue.\r\n  let timer = peek(timerQueue);\r\n  while (timer !== null) {\r\n    if (timer.callback === null) {\r\n      // Timer was cancelled.\r\n      pop(timerQueue);\r\n    } else if (timer.startTime <= currentTime) {\r\n      // Timer fired. Transfer to the task queue.\r\n      pop(timerQueue);\r\n      timer.sortIndex = timer.expirationTime;\r\n      push(taskQueue, timer);\r\n      if (enableProfiling) {\r\n        markTaskStart(timer, currentTime);\r\n        timer.isQueued = true;\r\n      }\r\n    } else {\r\n      // Remaining timers are pending.\r\n      return;\r\n    }\r\n    timer = peek(timerQueue);\r\n  }\r\n}\r\n\r\nfunction handleTimeout(currentTime) {\r\n  isHostTimeoutScheduled = false;\r\n  advanceTimers(currentTime);\r\n\r\n  if (!isHostCallbackScheduled) {\r\n    if (peek(taskQueue) !== null) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    } else {\r\n      const firstTimer = peek(timerQueue);\r\n      if (firstTimer !== null) {\r\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWork(hasTimeRemaining, initialTime) {\r\n  if (enableProfiling) {\r\n    markSchedulerUnsuspended(initialTime);\r\n  }\r\n\r\n  // We'll need a host callback the next time work is scheduled.\r\n  isHostCallbackScheduled = false;\r\n  if (isHostTimeoutScheduled) {\r\n    // We scheduled a timeout but it's no longer needed. Cancel it.\r\n    isHostTimeoutScheduled = false;\r\n    cancelHostTimeout();\r\n  }\r\n\r\n  isPerformingWork = true;\r\n  const previousPriorityLevel = currentPriorityLevel;\r\n  try {\r\n    if (enableProfiling) {\r\n      try {\r\n        return workLoop(hasTimeRemaining, initialTime);\r\n      } catch (error) {\r\n        if (currentTask !== null) {\r\n          const currentTime = getCurrentTime();\r\n          markTaskErrored(currentTask, currentTime);\r\n          currentTask.isQueued = false;\r\n        }\r\n        throw error;\r\n      }\r\n    } else {\r\n      // No catch in prod code path.\r\n      return workLoop(hasTimeRemaining, initialTime);\r\n    }\r\n  } finally {\r\n    currentTask = null;\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    isPerformingWork = false;\r\n    if (enableProfiling) {\r\n      const currentTime = getCurrentTime();\r\n      markSchedulerSuspended(currentTime);\r\n    }\r\n  }\r\n}\r\n\r\nfunction workLoop(hasTimeRemaining, initialTime) {\r\n  let currentTime = initialTime;\r\n  advanceTimers(currentTime);\r\n  currentTask = peek(taskQueue);\r\n  while (\r\n    currentTask !== null &&\r\n    !(enableSchedulerDebugging && isSchedulerPaused)\r\n  ) {\r\n    if (\r\n      currentTask.expirationTime > currentTime &&\r\n      (!hasTimeRemaining || shouldYieldToHost())\r\n    ) {\r\n      // This currentTask hasn't expired, and we've reached the deadline.\r\n      break;\r\n    }\r\n    const callback = currentTask.callback;\r\n    if (typeof callback === 'function') {\r\n      currentTask.callback = null;\r\n      currentPriorityLevel = currentTask.priorityLevel;\r\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\r\n      if (enableProfiling) {\r\n        markTaskRun(currentTask, currentTime);\r\n      }\r\n      const continuationCallback = callback(didUserCallbackTimeout);\r\n      currentTime = getCurrentTime();\r\n      if (typeof continuationCallback === 'function') {\r\n        currentTask.callback = continuationCallback;\r\n        if (enableProfiling) {\r\n          markTaskYield(currentTask, currentTime);\r\n        }\r\n      } else {\r\n        if (enableProfiling) {\r\n          markTaskCompleted(currentTask, currentTime);\r\n          currentTask.isQueued = false;\r\n        }\r\n        if (currentTask === peek(taskQueue)) {\r\n          pop(taskQueue);\r\n        }\r\n      }\r\n      advanceTimers(currentTime);\r\n    } else {\r\n      pop(taskQueue);\r\n    }\r\n    currentTask = peek(taskQueue);\r\n  }\r\n  // Return whether there's additional work\r\n  if (currentTask !== null) {\r\n    return true;\r\n  } else {\r\n    const firstTimer = peek(timerQueue);\r\n    if (firstTimer !== null) {\r\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n    case LowPriority:\r\n    case IdlePriority:\r\n      break;\r\n    default:\r\n      priorityLevel = NormalPriority;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_next(eventHandler) {\r\n  var priorityLevel;\r\n  switch (currentPriorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n      // Shift down to normal priority\r\n      priorityLevel = NormalPriority;\r\n      break;\r\n    default:\r\n      // Anything lower than normal priority should remain at the current level.\r\n      priorityLevel = currentPriorityLevel;\r\n      break;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_wrapCallback(callback) {\r\n  var parentPriorityLevel = currentPriorityLevel;\r\n  return function() {\r\n    // This is a fork of runWithPriority, inlined for performance.\r\n    var previousPriorityLevel = currentPriorityLevel;\r\n    currentPriorityLevel = parentPriorityLevel;\r\n\r\n    try {\r\n      return callback.apply(this, arguments);\r\n    } finally {\r\n      currentPriorityLevel = previousPriorityLevel;\r\n    }\r\n  };\r\n}\r\n\r\n\r\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\r\n  var currentTime = getCurrentTime();\r\n\r\n  var startTime;\r\n  if (typeof options === 'object' && options !== null) {\r\n    var delay = options.delay;\r\n    if (typeof delay === 'number' && delay > 0) {\r\n      startTime = currentTime + delay;\r\n    } else {\r\n      startTime = currentTime;\r\n    }\r\n  } else {\r\n    startTime = currentTime;\r\n  }\r\n\r\n  var timeout;\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\r\n      break;\r\n    case UserBlockingPriority:\r\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\r\n      break;\r\n    case IdlePriority:\r\n      timeout = IDLE_PRIORITY_TIMEOUT;\r\n      break;\r\n    case LowPriority:\r\n      timeout = LOW_PRIORITY_TIMEOUT;\r\n      break;\r\n    case NormalPriority:\r\n    default:\r\n      timeout = NORMAL_PRIORITY_TIMEOUT;\r\n      break;\r\n  }\r\n\r\n  var expirationTime = startTime + timeout;\r\n\r\n  var newTask = {\r\n    id: taskIdCounter++,\r\n    callback,\r\n    priorityLevel,\r\n    startTime,\r\n    expirationTime,\r\n    sortIndex: -1,\r\n  };\r\n  if (enableProfiling) {\r\n    newTask.isQueued = false;\r\n  }\r\n\r\n  if (startTime > currentTime) {\r\n    // This is a delayed task.\r\n    newTask.sortIndex = startTime;\r\n    push(timerQueue, newTask);\r\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\r\n      // All tasks are delayed, and this is the task with the earliest delay.\r\n      if (isHostTimeoutScheduled) {\r\n        // Cancel an existing timeout.\r\n        cancelHostTimeout();\r\n      } else {\r\n        isHostTimeoutScheduled = true;\r\n      }\r\n      // Schedule a timeout.\r\n      requestHostTimeout(handleTimeout, startTime - currentTime);\r\n    }\r\n  } else {\r\n    newTask.sortIndex = expirationTime;\r\n    push(taskQueue, newTask);\r\n    if (enableProfiling) {\r\n      markTaskStart(newTask, currentTime);\r\n      newTask.isQueued = true;\r\n    }\r\n    // Schedule a host callback, if needed. If we're already performing work,\r\n    // wait until the next time we yield.\r\n    if (!isHostCallbackScheduled && !isPerformingWork) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    }\r\n  }\r\n\r\n  return newTask;\r\n}\r\n\r\nfunction unstable_pauseExecution() {\r\n  isSchedulerPaused = true;\r\n}\r\n\r\nfunction unstable_continueExecution() {\r\n  isSchedulerPaused = false;\r\n  if (!isHostCallbackScheduled && !isPerformingWork) {\r\n    isHostCallbackScheduled = true;\r\n    requestHostCallback(flushWork);\r\n  }\r\n}\r\n\r\nfunction unstable_getFirstCallbackNode() {\r\n  return peek(taskQueue);\r\n}\r\n\r\nfunction unstable_cancelCallback(task) {\r\n  if (enableProfiling) {\r\n    if (task.isQueued) {\r\n      const currentTime = getCurrentTime();\r\n      markTaskCanceled(task, currentTime);\r\n      task.isQueued = false;\r\n    }\r\n  }\r\n\r\n  // Null out the callback to indicate the task has been canceled. (Can't\r\n  // remove from the queue because you can't remove arbitrary nodes from an\r\n  // array based heap, only the first one.)\r\n  task.callback = null;\r\n}\r\n\r\nfunction unstable_getCurrentPriorityLevel() {\r\n  return currentPriorityLevel;\r\n}\r\n\r\nconst unstable_requestPaint = requestPaint;\r\n\r\nexport {\r\n  ImmediatePriority as unstable_ImmediatePriority,\r\n  UserBlockingPriority as unstable_UserBlockingPriority,\r\n  NormalPriority as unstable_NormalPriority,\r\n  IdlePriority as unstable_IdlePriority,\r\n  LowPriority as unstable_LowPriority,\r\n  unstable_runWithPriority,\r\n  unstable_next,\r\n  unstable_scheduleCallback,\r\n  unstable_cancelCallback,\r\n  unstable_wrapCallback,\r\n  unstable_getCurrentPriorityLevel,\r\n  shouldYieldToHost as unstable_shouldYield,\r\n  unstable_requestPaint,\r\n  unstable_continueExecution,\r\n  unstable_pauseExecution,\r\n  unstable_getFirstCallbackNode,\r\n  getCurrentTime as unstable_now,\r\n  forceFrameRate as unstable_forceFrameRate,\r\n};\r\n\r\nexport const unstable_Profiling = enableProfiling\r\n  ? {\r\n      startLoggingProfilingEvents,\r\n      stopLoggingProfilingEvents,\r\n    }\r\n  : null;\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "completeWork 逻辑正如注释提到的： 执行剩下的工作 然后看是否有兄弟节点 有就返回兄弟节点 没有就返回父亲节点\n这样递归的返回到root节点为止",
      "line": 1670,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "这个函数就是Schedule 回调函数  也就是Schedule实际要执行的函数（这个concurrent模式下执行",
      "line": 740,
      "selection": {
        "start": {
          "line": 740,
          "character": 10
        },
        "end": {
          "line": 740,
          "character": 37
        }
      },
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "进入render 阶段\n",
      "line": 780,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "调用fiber构造循环函数",
      "line": 1592,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "Fiber构建循环（以树为数据结构, 从上至下执行深度优先遍历）\n========================================\n这里很有意思  相当于深度遍历一个树  在每棵树上面执行beginWork 和 completeWork 并且返回下一个 tree\n然后在这这个循环函数判断返回的 tree 是否是叶子节点  如果不是 则继续循环往下执行",
      "line": 1635,
      "selection": {
        "start": {
          "line": 1592,
          "character": 7
        },
        "end": {
          "line": 1592,
          "character": 25
        }
      },
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "工作单元（构建fiber节点 要注意  beginWork 只是在往下递归时候只是  completeWork 是在往回递归时候执行） \n理解beginWork 和completeWork执行顺序非常重要",
      "line": 1642,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberBeginWork.old.js",
      "description": "beginWork 主要需要不用的react元素类型 然后构建fiber",
      "line": 3083,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {ReactProviderType, ReactContext} from 'shared/ReactTypes';\r\nimport type {BlockComponent} from 'react/src/ReactBlock';\r\nimport type {LazyComponent as LazyComponentType} from 'react/src/ReactLazy';\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {MutableSource} from 'shared/ReactTypes';\r\nimport type {\r\n  SuspenseState,\r\n  SuspenseListRenderState,\r\n  SuspenseListTailMode,\r\n} from './ReactFiberSuspenseComponent.old';\r\nimport type {SuspenseContext} from './ReactFiberSuspenseContext.old';\r\nimport type {\r\n  OffscreenProps,\r\n  OffscreenState,\r\n} from './ReactFiberOffscreenComponent';\r\n\r\nimport checkPropTypes from 'shared/checkPropTypes';\r\n\r\nimport {\r\n  IndeterminateComponent,\r\n  FunctionComponent,\r\n  ClassComponent,\r\n  HostRoot,\r\n  HostComponent,\r\n  HostText,\r\n  HostPortal,\r\n  ForwardRef,\r\n  Fragment,\r\n  Mode,\r\n  ContextProvider,\r\n  ContextConsumer,\r\n  Profiler,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  LazyComponent,\r\n  IncompleteClassComponent,\r\n  FundamentalComponent,\r\n  ScopeComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n} from './ReactWorkTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Hydrating,\r\n  ContentReset,\r\n  DidCapture,\r\n  Update,\r\n  Ref,\r\n  Deletion,\r\n  ForceUpdateForLegacySuspense,\r\n} from './ReactFiberFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport {\r\n  debugRenderPhaseSideEffectsForStrictMode,\r\n  disableLegacyContext,\r\n  disableModulePatternComponents,\r\n  enableProfilerTimer,\r\n  enableSchedulerTracing,\r\n  enableSuspenseServerRenderer,\r\n  enableFundamentalAPI,\r\n  warnAboutDefaultPropsOnFunctionComponents,\r\n  enableScopeAPI,\r\n  enableBlocksAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport invariant from 'shared/invariant';\r\nimport shallowEqual from 'shared/shallowEqual';\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {REACT_LAZY_TYPE, getIteratorFn} from 'shared/ReactSymbols';\r\nimport {\r\n  getCurrentFiberOwnerNameInDevOrNull,\r\n  setIsRendering,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  resolveFunctionForHotReloading,\r\n  resolveForwardRefForHotReloading,\r\n  resolveClassForHotReloading,\r\n} from './ReactFiberHotReloading.old';\r\n\r\nimport {\r\n  mountChildFibers,\r\n  reconcileChildFibers,\r\n  cloneChildFibers,\r\n} from './ReactChildFiber.old';\r\nimport {\r\n  processUpdateQueue,\r\n  cloneUpdateQueue,\r\n  initializeUpdateQueue,\r\n} from './ReactUpdateQueue.old';\r\nimport {\r\n  NoLane,\r\n  NoLanes,\r\n  SyncLane,\r\n  OffscreenLane,\r\n  DefaultHydrationLane,\r\n  SomeRetryLane,\r\n  NoTimestamp,\r\n  includesSomeLane,\r\n  laneToLanes,\r\n  removeLanes,\r\n  mergeLanes,\r\n  getBumpedLaneForHydration,\r\n} from './ReactFiberLane';\r\nimport {\r\n  ConcurrentMode,\r\n  NoMode,\r\n  ProfileMode,\r\n  StrictMode,\r\n  BlockingMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  shouldSetTextContent,\r\n  isSuspenseInstancePending,\r\n  isSuspenseInstanceFallback,\r\n  registerSuspenseInstanceRetry,\r\n  supportsHydration,\r\n} from './ReactFiberHostConfig';\r\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\r\nimport {shouldSuspend} from './ReactFiberReconciler';\r\nimport {pushHostContext, pushHostContainer} from './ReactFiberHostContext.old';\r\nimport {\r\n  suspenseStackCursor,\r\n  pushSuspenseContext,\r\n  InvisibleParentSuspenseContext,\r\n  ForceSuspenseFallback,\r\n  hasSuspenseContext,\r\n  setDefaultShallowSuspenseContext,\r\n  addSubtreeSuspenseContext,\r\n  setShallowSuspenseContext,\r\n} from './ReactFiberSuspenseContext.old';\r\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent.old';\r\nimport {\r\n  pushProvider,\r\n  propagateContextChange,\r\n  readContext,\r\n  prepareToReadContext,\r\n  calculateChangedBits,\r\n  scheduleWorkOnParentPath,\r\n} from './ReactFiberNewContext.old';\r\nimport {renderWithHooks, bailoutHooks} from './ReactFiberHooks.old';\r\nimport {stopProfilerTimerIfRunning} from './ReactProfilerTimer.old';\r\nimport {\r\n  getMaskedContext,\r\n  getUnmaskedContext,\r\n  hasContextChanged as hasLegacyContextChanged,\r\n  pushContextProvider as pushLegacyContextProvider,\r\n  isContextProvider as isLegacyContextProvider,\r\n  pushTopLevelContextObject,\r\n  invalidateContextProvider,\r\n} from './ReactFiberContext.old';\r\nimport {\r\n  enterHydrationState,\r\n  reenterHydrationStateFromDehydratedSuspenseInstance,\r\n  resetHydrationState,\r\n  tryToClaimNextHydratableInstance,\r\n  warnIfHydrating,\r\n} from './ReactFiberHydrationContext.old';\r\nimport {\r\n  adoptClassInstance,\r\n  applyDerivedStateFromProps,\r\n  constructClassInstance,\r\n  mountClassInstance,\r\n  resumeMountClassInstance,\r\n  updateClassInstance,\r\n} from './ReactFiberClassComponent.old';\r\nimport {resolveDefaultProps} from './ReactFiberLazyComponent.old';\r\nimport {\r\n  resolveLazyComponentTag,\r\n  createFiberFromTypeAndProps,\r\n  createFiberFromFragment,\r\n  createFiberFromOffscreen,\r\n  createWorkInProgress,\r\n  isSimpleFunctionComponent,\r\n} from './ReactFiber.old';\r\nimport {\r\n  markSpawnedWork,\r\n  retryDehydratedSuspenseBoundary,\r\n  scheduleUpdateOnFiber,\r\n  renderDidSuspendDelayIfPossible,\r\n  markSkippedUpdateLanes,\r\n  getWorkInProgressRoot,\r\n  pushRenderLanes,\r\n  getExecutionContext,\r\n  RetryAfterError,\r\n  NoContext,\r\n} from './ReactFiberWorkLoop.old';\r\nimport {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';\r\nimport {setWorkInProgressVersion} from './ReactMutableSource.old';\r\n\r\nimport {disableLogs, reenableLogs} from 'shared/ConsolePatchingDev';\r\n\r\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\n\r\nlet didReceiveUpdate: boolean = false;\r\n\r\nlet didWarnAboutBadClass;\r\nlet didWarnAboutModulePatternComponent;\r\nlet didWarnAboutContextTypeOnFunctionComponent;\r\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\r\nlet didWarnAboutFunctionRefs;\r\nexport let didWarnAboutReassigningProps;\r\nlet didWarnAboutRevealOrder;\r\nlet didWarnAboutTailOptions;\r\nlet didWarnAboutDefaultPropsOnFunctionComponent;\r\n\r\nif (__DEV__) {\r\n  didWarnAboutBadClass = {};\r\n  didWarnAboutModulePatternComponent = {};\r\n  didWarnAboutContextTypeOnFunctionComponent = {};\r\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\r\n  didWarnAboutFunctionRefs = {};\r\n  didWarnAboutReassigningProps = false;\r\n  didWarnAboutRevealOrder = {};\r\n  didWarnAboutTailOptions = {};\r\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\r\n}\r\n\r\nexport function reconcileChildren(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  nextChildren: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (current === null) {\r\n    // If this is a fresh new component that hasn't been rendered yet, we\r\n    // won't update its child set by applying minimal side-effects. Instead,\r\n    // we will add them all to the child before it gets rendered. That means\r\n    // we can optimize this reconciliation pass by not tracking side-effects.\r\n    workInProgress.child = mountChildFibers(\r\n      workInProgress,\r\n      null,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    // If the current child is the same as the work in progress, it means that\r\n    // we haven't yet started any work on these children. Therefore, we use\r\n    // the clone algorithm to create a copy of all the current children.\r\n\r\n    // If we had any progressed work already, that is invalid at this point so\r\n    // let's throw it out.\r\n    workInProgress.child = reconcileChildFibers(\r\n      workInProgress,\r\n      current.child,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n  }\r\n}\r\n\r\nfunction forceUnmountCurrentAndReconcile(\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  nextChildren: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  // This function is fork of reconcileChildren. It's used in cases where we\r\n  // want to reconcile without matching against the existing set. This has the\r\n  // effect of all current children being unmounted; even if the type and key\r\n  // are the same, the old child is unmounted and a new child is created.\r\n  //\r\n  // To do this, we're going to go through the reconcile algorithm twice. In\r\n  // the first pass, we schedule a deletion for all the current children by\r\n  // passing null.\r\n  workInProgress.child = reconcileChildFibers(\r\n    workInProgress,\r\n    current.child,\r\n    null,\r\n    renderLanes,\r\n  );\r\n  // In the second pass, we mount the new children. The trick here is that we\r\n  // pass null in place of where we usually pass the current child set. This has\r\n  // the effect of remounting all children regardless of whether their\r\n  // identities match.\r\n  workInProgress.child = reconcileChildFibers(\r\n    workInProgress,\r\n    null,\r\n    nextChildren,\r\n    renderLanes,\r\n  );\r\n}\r\n\r\nfunction updateForwardRef(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  // TODO: current can be non-null here even if the component\r\n  // hasn't yet mounted. This happens after the first render suspends.\r\n  // We'll need to figure out if this is fine or can cause issues.\r\n\r\n  if (__DEV__) {\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      const innerPropTypes = Component.propTypes;\r\n      if (innerPropTypes) {\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentName(Component),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  const render = Component.render;\r\n  const ref = workInProgress.ref;\r\n\r\n  // The rest is a fork of updateFunctionComponent\r\n  let nextChildren;\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  if (__DEV__) {\r\n    ReactCurrentOwner.current = workInProgress;\r\n    setIsRendering(true);\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      render,\r\n      nextProps,\r\n      ref,\r\n      renderLanes,\r\n    );\r\n    if (\r\n      debugRenderPhaseSideEffectsForStrictMode &&\r\n      workInProgress.mode & StrictMode\r\n    ) {\r\n      disableLogs();\r\n      try {\r\n        nextChildren = renderWithHooks(\r\n          current,\r\n          workInProgress,\r\n          render,\r\n          nextProps,\r\n          ref,\r\n          renderLanes,\r\n        );\r\n      } finally {\r\n        reenableLogs();\r\n      }\r\n    }\r\n    setIsRendering(false);\r\n  } else {\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      render,\r\n      nextProps,\r\n      ref,\r\n      renderLanes,\r\n    );\r\n  }\r\n\r\n  if (current !== null && !didReceiveUpdate) {\r\n    bailoutHooks(current, workInProgress, renderLanes);\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateMemoComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  updateLanes: Lanes,\r\n  renderLanes: Lanes,\r\n): null | Fiber {\r\n  if (current === null) {\r\n    const type = Component.type;\r\n    if (\r\n      isSimpleFunctionComponent(type) &&\r\n      Component.compare === null &&\r\n      // SimpleMemoComponent codepath doesn't resolve outer props either.\r\n      Component.defaultProps === undefined\r\n    ) {\r\n      let resolvedType = type;\r\n      if (__DEV__) {\r\n        resolvedType = resolveFunctionForHotReloading(type);\r\n      }\r\n      // If this is a plain function component without default props,\r\n      // and with only the default shallow comparison, we upgrade it\r\n      // to a SimpleMemoComponent to allow fast path updates.\r\n      workInProgress.tag = SimpleMemoComponent;\r\n      workInProgress.type = resolvedType;\r\n      if (__DEV__) {\r\n        validateFunctionComponentInDev(workInProgress, type);\r\n      }\r\n      return updateSimpleMemoComponent(\r\n        current,\r\n        workInProgress,\r\n        resolvedType,\r\n        nextProps,\r\n        updateLanes,\r\n        renderLanes,\r\n      );\r\n    }\r\n    if (__DEV__) {\r\n      const innerPropTypes = type.propTypes;\r\n      if (innerPropTypes) {\r\n        // Inner memo component props aren't currently validated in createElement.\r\n        // We could move it there, but we'd still need this for lazy code path.\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentName(type),\r\n        );\r\n      }\r\n    }\r\n    const child = createFiberFromTypeAndProps(\r\n      Component.type,\r\n      null,\r\n      nextProps,\r\n      workInProgress,\r\n      workInProgress.mode,\r\n      renderLanes,\r\n    );\r\n    child.ref = workInProgress.ref;\r\n    child.return = workInProgress;\r\n    workInProgress.child = child;\r\n    return child;\r\n  }\r\n  if (__DEV__) {\r\n    const type = Component.type;\r\n    const innerPropTypes = type.propTypes;\r\n    if (innerPropTypes) {\r\n      // Inner memo component props aren't currently validated in createElement.\r\n      // We could move it there, but we'd still need this for lazy code path.\r\n      checkPropTypes(\r\n        innerPropTypes,\r\n        nextProps, // Resolved props\r\n        'prop',\r\n        getComponentName(type),\r\n      );\r\n    }\r\n  }\r\n  const currentChild = ((current.child: any): Fiber); // This is always exactly one child\r\n  if (!includesSomeLane(updateLanes, renderLanes)) {\r\n    // This will be the props with resolved defaultProps,\r\n    // unlike current.memoizedProps which will be the unresolved ones.\r\n    const prevProps = currentChild.memoizedProps;\r\n    // Default to shallow comparison\r\n    let compare = Component.compare;\r\n    compare = compare !== null ? compare : shallowEqual;\r\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\r\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n    }\r\n  }\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  const newChild = createWorkInProgress(currentChild, nextProps);\r\n  newChild.ref = workInProgress.ref;\r\n  newChild.return = workInProgress;\r\n  workInProgress.child = newChild;\r\n  return newChild;\r\n}\r\n\r\nfunction updateSimpleMemoComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  updateLanes: Lanes,\r\n  renderLanes: Lanes,\r\n): null | Fiber {\r\n  // TODO: current can be non-null here even if the component\r\n  // hasn't yet mounted. This happens when the inner render suspends.\r\n  // We'll need to figure out if this is fine or can cause issues.\r\n\r\n  if (__DEV__) {\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      let outerMemoType = workInProgress.elementType;\r\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\r\n        // We warn when you define propTypes on lazy()\r\n        // so let's just skip over it to find memo() outer wrapper.\r\n        // Inner props for memo are validated later.\r\n        const lazyComponent: LazyComponentType<any, any> = outerMemoType;\r\n        const payload = lazyComponent._payload;\r\n        const init = lazyComponent._init;\r\n        try {\r\n          outerMemoType = init(payload);\r\n        } catch (x) {\r\n          outerMemoType = null;\r\n        }\r\n        // Inner propTypes will be validated in the function component path.\r\n        const outerPropTypes = outerMemoType && (outerMemoType: any).propTypes;\r\n        if (outerPropTypes) {\r\n          checkPropTypes(\r\n            outerPropTypes,\r\n            nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\r\n            'prop',\r\n            getComponentName(outerMemoType),\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (current !== null) {\r\n    const prevProps = current.memoizedProps;\r\n    if (\r\n      shallowEqual(prevProps, nextProps) &&\r\n      current.ref === workInProgress.ref &&\r\n      // Prevent bailout if the implementation changed due to hot reload.\r\n      (__DEV__ ? workInProgress.type === current.type : true)\r\n    ) {\r\n      didReceiveUpdate = false;\r\n      if (!includesSomeLane(renderLanes, updateLanes)) {\r\n        // The pending lanes were cleared at the beginning of beginWork. We're\r\n        // about to bail out, but there might be other lanes that weren't\r\n        // included in the current render. Usually, the priority level of the\r\n        // remaining updates is accumlated during the evaluation of the\r\n        // component (i.e. when processing the update queue). But since since\r\n        // we're bailing out early *without* evaluating the component, we need\r\n        // to account for it here, too. Reset to the value of the current fiber.\r\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\r\n        // because a MemoComponent fiber does not have hooks or an update queue;\r\n        // rather, it wraps around an inner component, which may or may not\r\n        // contains hooks.\r\n        // TODO: Move the reset at in beginWork out of the common path so that\r\n        // this is no longer necessary.\r\n        workInProgress.lanes = current.lanes;\r\n        return bailoutOnAlreadyFinishedWork(\r\n          current,\r\n          workInProgress,\r\n          renderLanes,\r\n        );\r\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\r\n        // This is a special case that only exists for legacy mode.\r\n        // See https://github.com/facebook/react/pull/19216.\r\n        didReceiveUpdate = true;\r\n      }\r\n    }\r\n  }\r\n  return updateFunctionComponent(\r\n    current,\r\n    workInProgress,\r\n    Component,\r\n    nextProps,\r\n    renderLanes,\r\n  );\r\n}\r\n\r\nfunction updateOffscreenComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const nextProps: OffscreenProps = workInProgress.pendingProps;\r\n  const nextChildren = nextProps.children;\r\n\r\n  const prevState: OffscreenState | null =\r\n    current !== null ? current.memoizedState : null;\r\n\r\n  if (\r\n    nextProps.mode === 'hidden' ||\r\n    nextProps.mode === 'unstable-defer-without-hiding'\r\n  ) {\r\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\r\n      // In legacy sync mode, don't defer the subtree. Render it now.\r\n      // TODO: Figure out what we should do in Blocking mode.\r\n      const nextState: OffscreenState = {\r\n        baseLanes: NoLanes,\r\n      };\r\n      workInProgress.memoizedState = nextState;\r\n      pushRenderLanes(workInProgress, renderLanes);\r\n    } else if (!includesSomeLane(renderLanes, (OffscreenLane: Lane))) {\r\n      let nextBaseLanes;\r\n      if (prevState !== null) {\r\n        const prevBaseLanes = prevState.baseLanes;\r\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\r\n      } else {\r\n        nextBaseLanes = renderLanes;\r\n      }\r\n\r\n      // Schedule this fiber to re-render at offscreen priority. Then bailout.\r\n      if (enableSchedulerTracing) {\r\n        markSpawnedWork((OffscreenLane: Lane));\r\n      }\r\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(\r\n        OffscreenLane,\r\n      );\r\n      const nextState: OffscreenState = {\r\n        baseLanes: nextBaseLanes,\r\n      };\r\n      workInProgress.memoizedState = nextState;\r\n      // We're about to bail out, but we need to push this to the stack anyway\r\n      // to avoid a push/pop misalignment.\r\n      pushRenderLanes(workInProgress, nextBaseLanes);\r\n      return null;\r\n    } else {\r\n      // Rendering at offscreen, so we can clear the base lanes.\r\n      const nextState: OffscreenState = {\r\n        baseLanes: NoLanes,\r\n      };\r\n      workInProgress.memoizedState = nextState;\r\n      // Push the lanes that were skipped when we bailed out.\r\n      const subtreeRenderLanes =\r\n        prevState !== null ? prevState.baseLanes : renderLanes;\r\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\r\n    }\r\n  } else {\r\n    let subtreeRenderLanes;\r\n    if (prevState !== null) {\r\n      subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\r\n      // Since we're not hidden anymore, reset the state\r\n      workInProgress.memoizedState = null;\r\n    } else {\r\n      // We weren't previously hidden, and we still aren't, so there's nothing\r\n      // special to do. Need to push to the stack regardless, though, to avoid\r\n      // a push/pop misalignment.\r\n      subtreeRenderLanes = renderLanes;\r\n    }\r\n    pushRenderLanes(workInProgress, subtreeRenderLanes);\r\n  }\r\n\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\n// Note: These happen to have identical begin phases, for now. We shouldn't hold\r\n// ourselves to this constraint, though. If the behavior diverges, we should\r\n// fork the function.\r\nconst updateLegacyHiddenComponent = updateOffscreenComponent;\r\n\r\nfunction updateFragment(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const nextChildren = workInProgress.pendingProps;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateMode(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const nextChildren = workInProgress.pendingProps.children;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateProfiler(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (enableProfilerTimer) {\r\n    workInProgress.flags |= Update;\r\n\r\n    // Reset effect durations for the next eventual effect phase.\r\n    // These are reset during render to allow the DevTools commit hook a chance to read them,\r\n    const stateNode = workInProgress.stateNode;\r\n    stateNode.effectDuration = 0;\r\n    stateNode.passiveEffectDuration = 0;\r\n  }\r\n  const nextProps = workInProgress.pendingProps;\r\n  const nextChildren = nextProps.children;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction markRef(current: Fiber | null, workInProgress: Fiber) {\r\n  const ref = workInProgress.ref;\r\n  if (\r\n    (current === null && ref !== null) ||\r\n    (current !== null && current.ref !== ref)\r\n  ) {\r\n    // Schedule a Ref effect\r\n    workInProgress.flags |= Ref;\r\n  }\r\n}\r\n\r\nfunction updateFunctionComponent(\r\n  current,\r\n  workInProgress,\r\n  Component,\r\n  nextProps: any,\r\n  renderLanes,\r\n) {\r\n  if (__DEV__) {\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      const innerPropTypes = Component.propTypes;\r\n      if (innerPropTypes) {\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentName(Component),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let context;\r\n  if (!disableLegacyContext) {\r\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\r\n    context = getMaskedContext(workInProgress, unmaskedContext);\r\n  }\r\n\r\n  let nextChildren;\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  if (__DEV__) {\r\n    ReactCurrentOwner.current = workInProgress;\r\n    setIsRendering(true);\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      context,\r\n      renderLanes,\r\n    );\r\n    if (\r\n      debugRenderPhaseSideEffectsForStrictMode &&\r\n      workInProgress.mode & StrictMode\r\n    ) {\r\n      disableLogs();\r\n      try {\r\n        nextChildren = renderWithHooks(\r\n          current,\r\n          workInProgress,\r\n          Component,\r\n          nextProps,\r\n          context,\r\n          renderLanes,\r\n        );\r\n      } finally {\r\n        reenableLogs();\r\n      }\r\n    }\r\n    setIsRendering(false);\r\n  } else {\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      context,\r\n      renderLanes,\r\n    );\r\n  }\r\n\r\n  if (current !== null && !didReceiveUpdate) {\r\n    bailoutHooks(current, workInProgress, renderLanes);\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateBlock<Props, Data>(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  block: BlockComponent<Props, Data>,\r\n  nextProps: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  // TODO: current can be non-null here even if the component\r\n  // hasn't yet mounted. This happens after the first render suspends.\r\n  // We'll need to figure out if this is fine or can cause issues.\r\n\r\n  const render = block._render;\r\n  const data = block._data;\r\n\r\n  // The rest is a fork of updateFunctionComponent\r\n  let nextChildren;\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  if (__DEV__) {\r\n    ReactCurrentOwner.current = workInProgress;\r\n    setIsRendering(true);\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      render,\r\n      nextProps,\r\n      data,\r\n      renderLanes,\r\n    );\r\n    if (\r\n      debugRenderPhaseSideEffectsForStrictMode &&\r\n      workInProgress.mode & StrictMode\r\n    ) {\r\n      disableLogs();\r\n      try {\r\n        nextChildren = renderWithHooks(\r\n          current,\r\n          workInProgress,\r\n          render,\r\n          nextProps,\r\n          data,\r\n          renderLanes,\r\n        );\r\n      } finally {\r\n        reenableLogs();\r\n      }\r\n    }\r\n    setIsRendering(false);\r\n  } else {\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      render,\r\n      nextProps,\r\n      data,\r\n      renderLanes,\r\n    );\r\n  }\r\n\r\n  if (current !== null && !didReceiveUpdate) {\r\n    bailoutHooks(current, workInProgress, renderLanes);\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateClassComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (__DEV__) {\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      const innerPropTypes = Component.propTypes;\r\n      if (innerPropTypes) {\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentName(Component),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Push context providers early to prevent context stack mismatches.\r\n  // During mounting we don't know the child context yet as the instance doesn't exist.\r\n  // We will invalidate the child context in finishClassComponent() right after rendering.\r\n  let hasContext;\r\n  if (isLegacyContextProvider(Component)) {\r\n    hasContext = true;\r\n    pushLegacyContextProvider(workInProgress);\r\n  } else {\r\n    hasContext = false;\r\n  }\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n\r\n  const instance = workInProgress.stateNode;\r\n  let shouldUpdate;\r\n  if (instance === null) {\r\n    if (current !== null) {\r\n      // A class component without an instance only mounts if it suspended\r\n      // inside a non-concurrent tree, in an inconsistent state. We want to\r\n      // treat it like a new mount, even though an empty version of it already\r\n      // committed. Disconnect the alternate pointers.\r\n      current.alternate = null;\r\n      workInProgress.alternate = null;\r\n      // Since this is conceptually a new fiber, schedule a Placement effect\r\n      workInProgress.flags |= Placement;\r\n    }\r\n    // In the initial pass we might need to construct the instance.\r\n    constructClassInstance(workInProgress, Component, nextProps);\r\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\r\n    shouldUpdate = true;\r\n  } else if (current === null) {\r\n    // In a resume, we'll already have an instance we can reuse.\r\n    shouldUpdate = resumeMountClassInstance(\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    shouldUpdate = updateClassInstance(\r\n      current,\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      renderLanes,\r\n    );\r\n  }\r\n  const nextUnitOfWork = finishClassComponent(\r\n    current,\r\n    workInProgress,\r\n    Component,\r\n    shouldUpdate,\r\n    hasContext,\r\n    renderLanes,\r\n  );\r\n  if (__DEV__) {\r\n    const inst = workInProgress.stateNode;\r\n    if (shouldUpdate && inst.props !== nextProps) {\r\n      if (!didWarnAboutReassigningProps) {\r\n        console.error(\r\n          'It looks like %s is reassigning its own `this.props` while rendering. ' +\r\n            'This is not supported and can lead to confusing bugs.',\r\n          getComponentName(workInProgress.type) || 'a component',\r\n        );\r\n      }\r\n      didWarnAboutReassigningProps = true;\r\n    }\r\n  }\r\n  return nextUnitOfWork;\r\n}\r\n\r\nfunction finishClassComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  shouldUpdate: boolean,\r\n  hasContext: boolean,\r\n  renderLanes: Lanes,\r\n) {\r\n  // Refs should update even if shouldComponentUpdate returns false\r\n  markRef(current, workInProgress);\r\n\r\n  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\r\n\r\n  if (!shouldUpdate && !didCaptureError) {\r\n    // Context providers should defer to sCU for rendering\r\n    if (hasContext) {\r\n      invalidateContextProvider(workInProgress, Component, false);\r\n    }\r\n\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n\r\n  const instance = workInProgress.stateNode;\r\n\r\n  // Rerender\r\n  ReactCurrentOwner.current = workInProgress;\r\n  let nextChildren;\r\n  if (\r\n    didCaptureError &&\r\n    typeof Component.getDerivedStateFromError !== 'function'\r\n  ) {\r\n    // If we captured an error, but getDerivedStateFromError is not defined,\r\n    // unmount all the children. componentDidCatch will schedule an update to\r\n    // re-render a fallback. This is temporary until we migrate everyone to\r\n    // the new API.\r\n    // TODO: Warn in a future release.\r\n    nextChildren = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      stopProfilerTimerIfRunning(workInProgress);\r\n    }\r\n  } else {\r\n    if (__DEV__) {\r\n      setIsRendering(true);\r\n      nextChildren = instance.render();\r\n      if (\r\n        debugRenderPhaseSideEffectsForStrictMode &&\r\n        workInProgress.mode & StrictMode\r\n      ) {\r\n        disableLogs();\r\n        try {\r\n          instance.render();\r\n        } finally {\r\n          reenableLogs();\r\n        }\r\n      }\r\n      setIsRendering(false);\r\n    } else {\r\n      nextChildren = instance.render();\r\n    }\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  if (current !== null && didCaptureError) {\r\n    // If we're recovering from an error, reconcile without reusing any of\r\n    // the existing children. Conceptually, the normal children and the children\r\n    // that are shown on error are two different sets, so we shouldn't reuse\r\n    // normal children even if their identities match.\r\n    forceUnmountCurrentAndReconcile(\r\n      current,\r\n      workInProgress,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  }\r\n\r\n  // Memoize state using the values we just used to render.\r\n  // TODO: Restructure so we never read values from the instance.\r\n  workInProgress.memoizedState = instance.state;\r\n\r\n  // The context might have changed so we need to recalculate it.\r\n  if (hasContext) {\r\n    invalidateContextProvider(workInProgress, Component, true);\r\n  }\r\n\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction pushHostRootContext(workInProgress) {\r\n  const root = (workInProgress.stateNode: FiberRoot);\r\n  if (root.pendingContext) {\r\n    pushTopLevelContextObject(\r\n      workInProgress,\r\n      root.pendingContext,\r\n      root.pendingContext !== root.context,\r\n    );\r\n  } else if (root.context) {\r\n    // Should always be set\r\n    pushTopLevelContextObject(workInProgress, root.context, false);\r\n  }\r\n  pushHostContainer(workInProgress, root.containerInfo);\r\n}\r\n\r\nfunction updateHostRoot(current, workInProgress, renderLanes) {\r\n  pushHostRootContext(workInProgress);\r\n  const updateQueue = workInProgress.updateQueue;\r\n  invariant(\r\n    current !== null && updateQueue !== null,\r\n    'If the root does not have an updateQueue, we should have already ' +\r\n      'bailed out. This error is likely caused by a bug in React. Please ' +\r\n      'file an issue.',\r\n  );\r\n  const nextProps = workInProgress.pendingProps;\r\n  const prevState = workInProgress.memoizedState;\r\n  const prevChildren = prevState !== null ? prevState.element : null;\r\n  cloneUpdateQueue(current, workInProgress);\r\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\r\n  const nextState = workInProgress.memoizedState;\r\n  // Caution: React DevTools currently depends on this property\r\n  // being called \"element\".\r\n  const nextChildren = nextState.element;\r\n  if (nextChildren === prevChildren) {\r\n    resetHydrationState();\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n  const root: FiberRoot = workInProgress.stateNode;\r\n  if (root.hydrate && enterHydrationState(workInProgress)) {\r\n    // If we don't have any current children this might be the first pass.\r\n    // We always try to hydrate. If this isn't a hydration pass there won't\r\n    // be any children to hydrate which is effectively the same thing as\r\n    // not hydrating.\r\n\r\n    if (supportsHydration) {\r\n      const mutableSourceEagerHydrationData =\r\n        root.mutableSourceEagerHydrationData;\r\n      if (mutableSourceEagerHydrationData != null) {\r\n        for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\r\n          const mutableSource = ((mutableSourceEagerHydrationData[\r\n            i\r\n          ]: any): MutableSource<any>);\r\n          const version = mutableSourceEagerHydrationData[i + 1];\r\n          setWorkInProgressVersion(mutableSource, version);\r\n        }\r\n      }\r\n    }\r\n\r\n    const child = mountChildFibers(\r\n      workInProgress,\r\n      null,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n    workInProgress.child = child;\r\n\r\n    let node = child;\r\n    while (node) {\r\n      // Mark each child as hydrating. This is a fast path to know whether this\r\n      // tree is part of a hydrating tree. This is used to determine if a child\r\n      // node has fully mounted yet, and for scheduling event replaying.\r\n      // Conceptually this is similar to Placement in that a new subtree is\r\n      // inserted into the React tree here. It just happens to not need DOM\r\n      // mutations because it already exists.\r\n      node.flags = (node.flags & ~Placement) | Hydrating;\r\n      node = node.sibling;\r\n    }\r\n  } else {\r\n    // Otherwise reset hydration state in case we aborted and resumed another\r\n    // root.\r\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n    resetHydrationState();\r\n  }\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateHostComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  pushHostContext(workInProgress);\r\n\r\n  if (current === null) {\r\n    tryToClaimNextHydratableInstance(workInProgress);\r\n  }\r\n\r\n  const type = workInProgress.type;\r\n  const nextProps = workInProgress.pendingProps;\r\n  const prevProps = current !== null ? current.memoizedProps : null;\r\n\r\n  let nextChildren = nextProps.children;\r\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\r\n\r\n  if (isDirectTextChild) {\r\n    // We special case a direct text child of a host node. This is a common\r\n    // case. We won't handle it as a reified child. We will instead handle\r\n    // this in the host environment that also has access to this prop. That\r\n    // avoids allocating another HostText fiber and traversing it.\r\n    nextChildren = null;\r\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\r\n    // If we're switching from a direct text child to a normal child, or to\r\n    // empty, we need to schedule the text content to be reset.\r\n    workInProgress.flags |= ContentReset;\r\n  }\r\n\r\n  markRef(current, workInProgress);\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateHostText(current, workInProgress) {\r\n  if (current === null) {\r\n    tryToClaimNextHydratableInstance(workInProgress);\r\n  }\r\n  // Nothing to do here. This is terminal. We'll do the completion step\r\n  // immediately after.\r\n  return null;\r\n}\r\n\r\nfunction mountLazyComponent(\r\n  _current,\r\n  workInProgress,\r\n  elementType,\r\n  updateLanes,\r\n  renderLanes,\r\n) {\r\n  if (_current !== null) {\r\n    // A lazy component only mounts if it suspended inside a non-\r\n    // concurrent tree, in an inconsistent state. We want to treat it like\r\n    // a new mount, even though an empty version of it already committed.\r\n    // Disconnect the alternate pointers.\r\n    _current.alternate = null;\r\n    workInProgress.alternate = null;\r\n    // Since this is conceptually a new fiber, schedule a Placement effect\r\n    workInProgress.flags |= Placement;\r\n  }\r\n\r\n  const props = workInProgress.pendingProps;\r\n  const lazyComponent: LazyComponentType<any, any> = elementType;\r\n  const payload = lazyComponent._payload;\r\n  const init = lazyComponent._init;\r\n  let Component = init(payload);\r\n  // Store the unwrapped component in the type.\r\n  workInProgress.type = Component;\r\n  const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));\r\n  const resolvedProps = resolveDefaultProps(Component, props);\r\n  let child;\r\n  switch (resolvedTag) {\r\n    case FunctionComponent: {\r\n      if (__DEV__) {\r\n        validateFunctionComponentInDev(workInProgress, Component);\r\n        workInProgress.type = Component = resolveFunctionForHotReloading(\r\n          Component,\r\n        );\r\n      }\r\n      child = updateFunctionComponent(\r\n        null,\r\n        workInProgress,\r\n        Component,\r\n        resolvedProps,\r\n        renderLanes,\r\n      );\r\n      return child;\r\n    }\r\n    case ClassComponent: {\r\n      if (__DEV__) {\r\n        workInProgress.type = Component = resolveClassForHotReloading(\r\n          Component,\r\n        );\r\n      }\r\n      child = updateClassComponent(\r\n        null,\r\n        workInProgress,\r\n        Component,\r\n        resolvedProps,\r\n        renderLanes,\r\n      );\r\n      return child;\r\n    }\r\n    case ForwardRef: {\r\n      if (__DEV__) {\r\n        workInProgress.type = Component = resolveForwardRefForHotReloading(\r\n          Component,\r\n        );\r\n      }\r\n      child = updateForwardRef(\r\n        null,\r\n        workInProgress,\r\n        Component,\r\n        resolvedProps,\r\n        renderLanes,\r\n      );\r\n      return child;\r\n    }\r\n    case MemoComponent: {\r\n      if (__DEV__) {\r\n        if (workInProgress.type !== workInProgress.elementType) {\r\n          const outerPropTypes = Component.propTypes;\r\n          if (outerPropTypes) {\r\n            checkPropTypes(\r\n              outerPropTypes,\r\n              resolvedProps, // Resolved for outer only\r\n              'prop',\r\n              getComponentName(Component),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      child = updateMemoComponent(\r\n        null,\r\n        workInProgress,\r\n        Component,\r\n        resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\r\n        updateLanes,\r\n        renderLanes,\r\n      );\r\n      return child;\r\n    }\r\n    case Block: {\r\n      if (enableBlocksAPI) {\r\n        // TODO: Resolve for Hot Reloading.\r\n        child = updateBlock(\r\n          null,\r\n          workInProgress,\r\n          Component,\r\n          props,\r\n          renderLanes,\r\n        );\r\n        return child;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  let hint = '';\r\n  if (__DEV__) {\r\n    if (\r\n      Component !== null &&\r\n      typeof Component === 'object' &&\r\n      Component.$$typeof === REACT_LAZY_TYPE\r\n    ) {\r\n      hint = ' Did you wrap a component in React.lazy() more than once?';\r\n    }\r\n  }\r\n  // This message intentionally doesn't mention ForwardRef or MemoComponent\r\n  // because the fact that it's a separate type of work is an\r\n  // implementation detail.\r\n  invariant(\r\n    false,\r\n    'Element type is invalid. Received a promise that resolves to: %s. ' +\r\n      'Lazy element type must resolve to a class or function.%s',\r\n    Component,\r\n    hint,\r\n  );\r\n}\r\n\r\nfunction mountIncompleteClassComponent(\r\n  _current,\r\n  workInProgress,\r\n  Component,\r\n  nextProps,\r\n  renderLanes,\r\n) {\r\n  if (_current !== null) {\r\n    // An incomplete component only mounts if it suspended inside a non-\r\n    // concurrent tree, in an inconsistent state. We want to treat it like\r\n    // a new mount, even though an empty version of it already committed.\r\n    // Disconnect the alternate pointers.\r\n    _current.alternate = null;\r\n    workInProgress.alternate = null;\r\n    // Since this is conceptually a new fiber, schedule a Placement effect\r\n    workInProgress.flags |= Placement;\r\n  }\r\n\r\n  // Promote the fiber to a class and try rendering again.\r\n  workInProgress.tag = ClassComponent;\r\n\r\n  // The rest of this function is a fork of `updateClassComponent`\r\n\r\n  // Push context providers early to prevent context stack mismatches.\r\n  // During mounting we don't know the child context yet as the instance doesn't exist.\r\n  // We will invalidate the child context in finishClassComponent() right after rendering.\r\n  let hasContext;\r\n  if (isLegacyContextProvider(Component)) {\r\n    hasContext = true;\r\n    pushLegacyContextProvider(workInProgress);\r\n  } else {\r\n    hasContext = false;\r\n  }\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n\r\n  constructClassInstance(workInProgress, Component, nextProps);\r\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\r\n\r\n  return finishClassComponent(\r\n    null,\r\n    workInProgress,\r\n    Component,\r\n    true,\r\n    hasContext,\r\n    renderLanes,\r\n  );\r\n}\r\n\r\nfunction mountIndeterminateComponent(\r\n  _current,\r\n  workInProgress,\r\n  Component,\r\n  renderLanes,\r\n) {\r\n  if (_current !== null) {\r\n    // An indeterminate component only mounts if it suspended inside a non-\r\n    // concurrent tree, in an inconsistent state. We want to treat it like\r\n    // a new mount, even though an empty version of it already committed.\r\n    // Disconnect the alternate pointers.\r\n    _current.alternate = null;\r\n    workInProgress.alternate = null;\r\n    // Since this is conceptually a new fiber, schedule a Placement effect\r\n    workInProgress.flags |= Placement;\r\n  }\r\n\r\n  const props = workInProgress.pendingProps;\r\n  let context;\r\n  if (!disableLegacyContext) {\r\n    const unmaskedContext = getUnmaskedContext(\r\n      workInProgress,\r\n      Component,\r\n      false,\r\n    );\r\n    context = getMaskedContext(workInProgress, unmaskedContext);\r\n  }\r\n\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  let value;\r\n\r\n  if (__DEV__) {\r\n    if (\r\n      Component.prototype &&\r\n      typeof Component.prototype.render === 'function'\r\n    ) {\r\n      const componentName = getComponentName(Component) || 'Unknown';\r\n\r\n      if (!didWarnAboutBadClass[componentName]) {\r\n        console.error(\r\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\r\n            'This is likely to cause errors. Change %s to extend React.Component instead.',\r\n          componentName,\r\n          componentName,\r\n        );\r\n        didWarnAboutBadClass[componentName] = true;\r\n      }\r\n    }\r\n\r\n    if (workInProgress.mode & StrictMode) {\r\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\r\n    }\r\n\r\n    setIsRendering(true);\r\n    ReactCurrentOwner.current = workInProgress;\r\n    value = renderWithHooks(\r\n      null,\r\n      workInProgress,\r\n      Component,\r\n      props,\r\n      context,\r\n      renderLanes,\r\n    );\r\n    setIsRendering(false);\r\n  } else {\r\n    value = renderWithHooks(\r\n      null,\r\n      workInProgress,\r\n      Component,\r\n      props,\r\n      context,\r\n      renderLanes,\r\n    );\r\n  }\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n\r\n  if (__DEV__) {\r\n    // Support for module components is deprecated and is removed behind a flag.\r\n    // Whether or not it would crash later, we want to show a good message in DEV first.\r\n    if (\r\n      typeof value === 'object' &&\r\n      value !== null &&\r\n      typeof value.render === 'function' &&\r\n      value.$$typeof === undefined\r\n    ) {\r\n      const componentName = getComponentName(Component) || 'Unknown';\r\n      if (!didWarnAboutModulePatternComponent[componentName]) {\r\n        console.error(\r\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\r\n            'Change %s to a class that extends React.Component instead. ' +\r\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\r\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\r\n            'cannot be called with `new` by React.',\r\n          componentName,\r\n          componentName,\r\n          componentName,\r\n        );\r\n        didWarnAboutModulePatternComponent[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    // Run these checks in production only if the flag is off.\r\n    // Eventually we'll delete this branch altogether.\r\n    !disableModulePatternComponents &&\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    typeof value.render === 'function' &&\r\n    value.$$typeof === undefined\r\n  ) {\r\n    if (__DEV__) {\r\n      const componentName = getComponentName(Component) || 'Unknown';\r\n      if (!didWarnAboutModulePatternComponent[componentName]) {\r\n        console.error(\r\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\r\n            'Change %s to a class that extends React.Component instead. ' +\r\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\r\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\r\n            'cannot be called with `new` by React.',\r\n          componentName,\r\n          componentName,\r\n          componentName,\r\n        );\r\n        didWarnAboutModulePatternComponent[componentName] = true;\r\n      }\r\n    }\r\n\r\n    // Proceed under the assumption that this is a class instance\r\n    workInProgress.tag = ClassComponent;\r\n\r\n    // Throw out any hooks that were used.\r\n    workInProgress.memoizedState = null;\r\n    workInProgress.updateQueue = null;\r\n\r\n    // Push context providers early to prevent context stack mismatches.\r\n    // During mounting we don't know the child context yet as the instance doesn't exist.\r\n    // We will invalidate the child context in finishClassComponent() right after rendering.\r\n    let hasContext = false;\r\n    if (isLegacyContextProvider(Component)) {\r\n      hasContext = true;\r\n      pushLegacyContextProvider(workInProgress);\r\n    } else {\r\n      hasContext = false;\r\n    }\r\n\r\n    workInProgress.memoizedState =\r\n      value.state !== null && value.state !== undefined ? value.state : null;\r\n\r\n    initializeUpdateQueue(workInProgress);\r\n\r\n    const getDerivedStateFromProps = Component.getDerivedStateFromProps;\r\n    if (typeof getDerivedStateFromProps === 'function') {\r\n      applyDerivedStateFromProps(\r\n        workInProgress,\r\n        Component,\r\n        getDerivedStateFromProps,\r\n        props,\r\n      );\r\n    }\r\n\r\n    adoptClassInstance(workInProgress, value);\r\n    mountClassInstance(workInProgress, Component, props, renderLanes);\r\n    return finishClassComponent(\r\n      null,\r\n      workInProgress,\r\n      Component,\r\n      true,\r\n      hasContext,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    // Proceed under the assumption that this is a function component\r\n    workInProgress.tag = FunctionComponent;\r\n    if (__DEV__) {\r\n      if (disableLegacyContext && Component.contextTypes) {\r\n        console.error(\r\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\r\n            'Use React.createContext() with React.useContext() instead.',\r\n          getComponentName(Component) || 'Unknown',\r\n        );\r\n      }\r\n\r\n      if (\r\n        debugRenderPhaseSideEffectsForStrictMode &&\r\n        workInProgress.mode & StrictMode\r\n      ) {\r\n        disableLogs();\r\n        try {\r\n          value = renderWithHooks(\r\n            null,\r\n            workInProgress,\r\n            Component,\r\n            props,\r\n            context,\r\n            renderLanes,\r\n          );\r\n        } finally {\r\n          reenableLogs();\r\n        }\r\n      }\r\n    }\r\n    reconcileChildren(null, workInProgress, value, renderLanes);\r\n    if (__DEV__) {\r\n      validateFunctionComponentInDev(workInProgress, Component);\r\n    }\r\n    return workInProgress.child;\r\n  }\r\n}\r\n\r\nfunction validateFunctionComponentInDev(workInProgress: Fiber, Component: any) {\r\n  if (__DEV__) {\r\n    if (Component) {\r\n      if (Component.childContextTypes) {\r\n        console.error(\r\n          '%s(...): childContextTypes cannot be defined on a function component.',\r\n          Component.displayName || Component.name || 'Component',\r\n        );\r\n      }\r\n    }\r\n    if (workInProgress.ref !== null) {\r\n      let info = '';\r\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\r\n      if (ownerName) {\r\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\r\n      }\r\n\r\n      let warningKey = ownerName || workInProgress._debugID || '';\r\n      const debugSource = workInProgress._debugSource;\r\n      if (debugSource) {\r\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\r\n      }\r\n      if (!didWarnAboutFunctionRefs[warningKey]) {\r\n        didWarnAboutFunctionRefs[warningKey] = true;\r\n        console.error(\r\n          'Function components cannot be given refs. ' +\r\n            'Attempts to access this ref will fail. ' +\r\n            'Did you mean to use React.forwardRef()?%s',\r\n          info,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      warnAboutDefaultPropsOnFunctionComponents &&\r\n      Component.defaultProps !== undefined\r\n    ) {\r\n      const componentName = getComponentName(Component) || 'Unknown';\r\n\r\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\r\n        console.error(\r\n          '%s: Support for defaultProps will be removed from function components ' +\r\n            'in a future major release. Use JavaScript default parameters instead.',\r\n          componentName,\r\n        );\r\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\r\n      }\r\n    }\r\n\r\n    if (typeof Component.getDerivedStateFromProps === 'function') {\r\n      const componentName = getComponentName(Component) || 'Unknown';\r\n\r\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\r\n        console.error(\r\n          '%s: Function components do not support getDerivedStateFromProps.',\r\n          componentName,\r\n        );\r\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\r\n      }\r\n    }\r\n\r\n    if (\r\n      typeof Component.contextType === 'object' &&\r\n      Component.contextType !== null\r\n    ) {\r\n      const componentName = getComponentName(Component) || 'Unknown';\r\n\r\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\r\n        console.error(\r\n          '%s: Function components do not support contextType.',\r\n          componentName,\r\n        );\r\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst SUSPENDED_MARKER: SuspenseState = {\r\n  dehydrated: null,\r\n  retryLane: NoLane,\r\n};\r\n\r\nfunction mountSuspenseOffscreenState(renderLanes: Lanes): OffscreenState {\r\n  return {\r\n    baseLanes: renderLanes,\r\n  };\r\n}\r\n\r\nfunction updateSuspenseOffscreenState(\r\n  prevOffscreenState: OffscreenState,\r\n  renderLanes: Lanes,\r\n): OffscreenState {\r\n  return {\r\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\r\n  };\r\n}\r\n\r\n// TODO: Probably should inline this back\r\nfunction shouldRemainOnFallback(\r\n  suspenseContext: SuspenseContext,\r\n  current: null | Fiber,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  // If we're already showing a fallback, there are cases where we need to\r\n  // remain on that fallback regardless of whether the content has resolved.\r\n  // For example, SuspenseList coordinates when nested content appears.\r\n  if (current !== null) {\r\n    const suspenseState: SuspenseState = current.memoizedState;\r\n    if (suspenseState === null) {\r\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallack\r\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\r\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\r\n      // no fallback to remain on.\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Not currently showing content. Consult the Suspense context.\r\n  return hasSuspenseContext(\r\n    suspenseContext,\r\n    (ForceSuspenseFallback: SuspenseContext),\r\n  );\r\n}\r\n\r\nfunction getRemainingWorkInPrimaryTree(current: Fiber, renderLanes) {\r\n  // TODO: Should not remove render lanes that were pinged during this render\r\n  return removeLanes(current.childLanes, renderLanes);\r\n}\r\n\r\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\r\n  const nextProps = workInProgress.pendingProps;\r\n\r\n  // This is used by DevTools to force a boundary to suspend.\r\n  if (__DEV__) {\r\n    if (shouldSuspend(workInProgress)) {\r\n      workInProgress.flags |= DidCapture;\r\n    }\r\n  }\r\n\r\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\r\n\r\n  let showFallback = false;\r\n  const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\r\n\r\n  if (\r\n    didSuspend ||\r\n    shouldRemainOnFallback(\r\n      suspenseContext,\r\n      current,\r\n      workInProgress,\r\n      renderLanes,\r\n    )\r\n  ) {\r\n    // Something in this boundary's subtree already suspended. Switch to\r\n    // rendering the fallback children.\r\n    showFallback = true;\r\n    workInProgress.flags &= ~DidCapture;\r\n  } else {\r\n    // Attempting the main content\r\n    if (\r\n      current === null ||\r\n      (current.memoizedState: null | SuspenseState) !== null\r\n    ) {\r\n      // This is a new mount or this boundary is already showing a fallback state.\r\n      // Mark this subtree context as having at least one invisible parent that could\r\n      // handle the fallback state.\r\n      // Boundaries without fallbacks or should be avoided are not considered since\r\n      // they cannot handle preferred fallback states.\r\n      if (\r\n        nextProps.fallback !== undefined &&\r\n        nextProps.unstable_avoidThisFallback !== true\r\n      ) {\r\n        suspenseContext = addSubtreeSuspenseContext(\r\n          suspenseContext,\r\n          InvisibleParentSuspenseContext,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n\r\n  pushSuspenseContext(workInProgress, suspenseContext);\r\n\r\n  // OK, the next part is confusing. We're about to reconcile the Suspense\r\n  // boundary's children. This involves some custom reconcilation logic. Two\r\n  // main reasons this is so complicated.\r\n  //\r\n  // First, Legacy Mode has different semantics for backwards compatibility. The\r\n  // primary tree will commit in an inconsistent state, so when we do the\r\n  // second pass to render the fallback, we do some exceedingly, uh, clever\r\n  // hacks to make that not totally break. Like transferring effects and\r\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\r\n  // because we bailout on the primary tree completely and leave it in its old\r\n  // state, no effects. Same as what we do for Offscreen (except that\r\n  // Offscreen doesn't have the first render pass).\r\n  //\r\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\r\n  // different layout, where the child points to a dehydrated fragment, which\r\n  // contains the DOM rendered by the server.\r\n  //\r\n  // Third, even if you set all that aside, Suspense is like error boundaries in\r\n  // that we first we try to render one tree, and if that fails, we render again\r\n  // and switch to a different tree. Like a try/catch block. So we have to track\r\n  // which branch we're currently rendering. Ideally we would model this using\r\n  // a stack.\r\n  if (current === null) {\r\n    // Initial mount\r\n    // If we're currently hydrating, try to hydrate this boundary.\r\n    // But only if this has a fallback.\r\n    if (nextProps.fallback !== undefined) {\r\n      tryToClaimNextHydratableInstance(workInProgress);\r\n      // This could've been a dehydrated suspense component.\r\n      if (enableSuspenseServerRenderer) {\r\n        const suspenseState: null | SuspenseState =\r\n          workInProgress.memoizedState;\r\n        if (suspenseState !== null) {\r\n          const dehydrated = suspenseState.dehydrated;\r\n          if (dehydrated !== null) {\r\n            return mountDehydratedSuspenseComponent(\r\n              workInProgress,\r\n              dehydrated,\r\n              renderLanes,\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const nextPrimaryChildren = nextProps.children;\r\n    const nextFallbackChildren = nextProps.fallback;\r\n    if (showFallback) {\r\n      const fallbackFragment = mountSuspenseFallbackChildren(\r\n        workInProgress,\r\n        nextPrimaryChildren,\r\n        nextFallbackChildren,\r\n        renderLanes,\r\n      );\r\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\r\n        renderLanes,\r\n      );\r\n      workInProgress.memoizedState = SUSPENDED_MARKER;\r\n      return fallbackFragment;\r\n    } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {\r\n      // This is a CPU-bound tree. Skip this tree and show a placeholder to\r\n      // unblock the surrounding content. Then immediately retry after the\r\n      // initial commit.\r\n      const fallbackFragment = mountSuspenseFallbackChildren(\r\n        workInProgress,\r\n        nextPrimaryChildren,\r\n        nextFallbackChildren,\r\n        renderLanes,\r\n      );\r\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\r\n        renderLanes,\r\n      );\r\n      workInProgress.memoizedState = SUSPENDED_MARKER;\r\n\r\n      // Since nothing actually suspended, there will nothing to ping this to\r\n      // get it started back up to attempt the next item. While in terms of\r\n      // priority this work has the same priority as this current render, it's\r\n      // not part of the same transition once the transition has committed. If\r\n      // it's sync, we still want to yield so that it can be painted.\r\n      // Conceptually, this is really the same as pinging. We can use any\r\n      // RetryLane even if it's the one currently rendering since we're leaving\r\n      // it behind on this node.\r\n      workInProgress.lanes = SomeRetryLane;\r\n      if (enableSchedulerTracing) {\r\n        markSpawnedWork(SomeRetryLane);\r\n      }\r\n      return fallbackFragment;\r\n    } else {\r\n      return mountSuspensePrimaryChildren(\r\n        workInProgress,\r\n        nextPrimaryChildren,\r\n        renderLanes,\r\n      );\r\n    }\r\n  } else {\r\n    // This is an update.\r\n\r\n    // If the current fiber has a SuspenseState, that means it's already showing\r\n    // a fallback.\r\n    const prevState: null | SuspenseState = current.memoizedState;\r\n    if (prevState !== null) {\r\n      // The current tree is already showing a fallback\r\n\r\n      // Special path for hydration\r\n      if (enableSuspenseServerRenderer) {\r\n        const dehydrated = prevState.dehydrated;\r\n        if (dehydrated !== null) {\r\n          if (!didSuspend) {\r\n            return updateDehydratedSuspenseComponent(\r\n              current,\r\n              workInProgress,\r\n              dehydrated,\r\n              prevState,\r\n              renderLanes,\r\n            );\r\n          } else if (\r\n            (workInProgress.memoizedState: null | SuspenseState) !== null\r\n          ) {\r\n            // Something suspended and we should still be in dehydrated mode.\r\n            // Leave the existing child in place.\r\n            workInProgress.child = current.child;\r\n            // The dehydrated completion pass expects this flag to be there\r\n            // but the normal suspense pass doesn't.\r\n            workInProgress.flags |= DidCapture;\r\n            return null;\r\n          } else {\r\n            // Suspended but we should no longer be in dehydrated mode.\r\n            // Therefore we now have to render the fallback.\r\n            const nextPrimaryChildren = nextProps.children;\r\n            const nextFallbackChildren = nextProps.fallback;\r\n            const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(\r\n              current,\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              nextFallbackChildren,\r\n              renderLanes,\r\n            );\r\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\r\n              renderLanes,\r\n            );\r\n            workInProgress.memoizedState = SUSPENDED_MARKER;\r\n            return fallbackChildFragment;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (showFallback) {\r\n        const nextFallbackChildren = nextProps.fallback;\r\n        const nextPrimaryChildren = nextProps.children;\r\n        const fallbackChildFragment = updateSuspenseFallbackChildren(\r\n          current,\r\n          workInProgress,\r\n          nextPrimaryChildren,\r\n          nextFallbackChildren,\r\n          renderLanes,\r\n        );\r\n        const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n        const prevOffscreenState: OffscreenState | null = (current.child: any)\r\n          .memoizedState;\r\n        primaryChildFragment.memoizedState =\r\n          prevOffscreenState === null\r\n            ? mountSuspenseOffscreenState(renderLanes)\r\n            : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\r\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(\r\n          current,\r\n          renderLanes,\r\n        );\r\n        workInProgress.memoizedState = SUSPENDED_MARKER;\r\n        return fallbackChildFragment;\r\n      } else {\r\n        const nextPrimaryChildren = nextProps.children;\r\n        const primaryChildFragment = updateSuspensePrimaryChildren(\r\n          current,\r\n          workInProgress,\r\n          nextPrimaryChildren,\r\n          renderLanes,\r\n        );\r\n        workInProgress.memoizedState = null;\r\n        return primaryChildFragment;\r\n      }\r\n    } else {\r\n      // The current tree is not already showing a fallback.\r\n      if (showFallback) {\r\n        // Timed out.\r\n        const nextFallbackChildren = nextProps.fallback;\r\n        const nextPrimaryChildren = nextProps.children;\r\n        const fallbackChildFragment = updateSuspenseFallbackChildren(\r\n          current,\r\n          workInProgress,\r\n          nextPrimaryChildren,\r\n          nextFallbackChildren,\r\n          renderLanes,\r\n        );\r\n        const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n        const prevOffscreenState: OffscreenState | null = (current.child: any)\r\n          .memoizedState;\r\n        primaryChildFragment.memoizedState =\r\n          prevOffscreenState === null\r\n            ? mountSuspenseOffscreenState(renderLanes)\r\n            : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\r\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(\r\n          current,\r\n          renderLanes,\r\n        );\r\n        // Skip the primary children, and continue working on the\r\n        // fallback children.\r\n        workInProgress.memoizedState = SUSPENDED_MARKER;\r\n        return fallbackChildFragment;\r\n      } else {\r\n        // Still haven't timed out. Continue rendering the children, like we\r\n        // normally do.\r\n        const nextPrimaryChildren = nextProps.children;\r\n        const primaryChildFragment = updateSuspensePrimaryChildren(\r\n          current,\r\n          workInProgress,\r\n          nextPrimaryChildren,\r\n          renderLanes,\r\n        );\r\n        workInProgress.memoizedState = null;\r\n        return primaryChildFragment;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction mountSuspensePrimaryChildren(\r\n  workInProgress,\r\n  primaryChildren,\r\n  renderLanes,\r\n) {\r\n  const mode = workInProgress.mode;\r\n  const primaryChildProps: OffscreenProps = {\r\n    mode: 'visible',\r\n    children: primaryChildren,\r\n  };\r\n  const primaryChildFragment = createFiberFromOffscreen(\r\n    primaryChildProps,\r\n    mode,\r\n    renderLanes,\r\n    null,\r\n  );\r\n  primaryChildFragment.return = workInProgress;\r\n  workInProgress.child = primaryChildFragment;\r\n  return primaryChildFragment;\r\n}\r\n\r\nfunction mountSuspenseFallbackChildren(\r\n  workInProgress,\r\n  primaryChildren,\r\n  fallbackChildren,\r\n  renderLanes,\r\n) {\r\n  const mode = workInProgress.mode;\r\n  const progressedPrimaryFragment: Fiber | null = workInProgress.child;\r\n\r\n  const primaryChildProps: OffscreenProps = {\r\n    mode: 'hidden',\r\n    children: primaryChildren,\r\n  };\r\n\r\n  let primaryChildFragment;\r\n  let fallbackChildFragment;\r\n  if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {\r\n    // In legacy mode, we commit the primary tree as if it successfully\r\n    // completed, even though it's in an inconsistent state.\r\n    primaryChildFragment = progressedPrimaryFragment;\r\n    primaryChildFragment.childLanes = NoLanes;\r\n    primaryChildFragment.pendingProps = primaryChildProps;\r\n\r\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\r\n      // Reset the durations from the first pass so they aren't included in the\r\n      // final amounts. This seems counterintuitive, since we're intentionally\r\n      // not measuring part of the render phase, but this makes it match what we\r\n      // do in Concurrent Mode.\r\n      primaryChildFragment.actualDuration = 0;\r\n      primaryChildFragment.actualStartTime = -1;\r\n      primaryChildFragment.selfBaseDuration = 0;\r\n      primaryChildFragment.treeBaseDuration = 0;\r\n    }\r\n\r\n    fallbackChildFragment = createFiberFromFragment(\r\n      fallbackChildren,\r\n      mode,\r\n      renderLanes,\r\n      null,\r\n    );\r\n  } else {\r\n    primaryChildFragment = createFiberFromOffscreen(\r\n      primaryChildProps,\r\n      mode,\r\n      NoLanes,\r\n      null,\r\n    );\r\n    fallbackChildFragment = createFiberFromFragment(\r\n      fallbackChildren,\r\n      mode,\r\n      renderLanes,\r\n      null,\r\n    );\r\n  }\r\n\r\n  primaryChildFragment.return = workInProgress;\r\n  fallbackChildFragment.return = workInProgress;\r\n  primaryChildFragment.sibling = fallbackChildFragment;\r\n  workInProgress.child = primaryChildFragment;\r\n  return fallbackChildFragment;\r\n}\r\n\r\nfunction createWorkInProgressOffscreenFiber(\r\n  current: Fiber,\r\n  offscreenProps: OffscreenProps,\r\n) {\r\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\r\n  // wrapper function to constrain it.\r\n  return createWorkInProgress(current, offscreenProps);\r\n}\r\n\r\nfunction updateSuspensePrimaryChildren(\r\n  current,\r\n  workInProgress,\r\n  primaryChildren,\r\n  renderLanes,\r\n) {\r\n  const currentPrimaryChildFragment: Fiber = (current.child: any);\r\n  const currentFallbackChildFragment: Fiber | null =\r\n    currentPrimaryChildFragment.sibling;\r\n\r\n  const primaryChildFragment = createWorkInProgressOffscreenFiber(\r\n    currentPrimaryChildFragment,\r\n    {\r\n      mode: 'visible',\r\n      children: primaryChildren,\r\n    },\r\n  );\r\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\r\n    primaryChildFragment.lanes = renderLanes;\r\n  }\r\n  primaryChildFragment.return = workInProgress;\r\n  primaryChildFragment.sibling = null;\r\n  if (currentFallbackChildFragment !== null) {\r\n    // Delete the fallback child fragment\r\n    currentFallbackChildFragment.nextEffect = null;\r\n    currentFallbackChildFragment.flags = Deletion;\r\n    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;\r\n  }\r\n\r\n  workInProgress.child = primaryChildFragment;\r\n  return primaryChildFragment;\r\n}\r\n\r\nfunction updateSuspenseFallbackChildren(\r\n  current,\r\n  workInProgress,\r\n  primaryChildren,\r\n  fallbackChildren,\r\n  renderLanes,\r\n) {\r\n  const mode = workInProgress.mode;\r\n  const currentPrimaryChildFragment: Fiber = (current.child: any);\r\n  const currentFallbackChildFragment: Fiber | null =\r\n    currentPrimaryChildFragment.sibling;\r\n\r\n  const primaryChildProps: OffscreenProps = {\r\n    mode: 'hidden',\r\n    children: primaryChildren,\r\n  };\r\n\r\n  let primaryChildFragment;\r\n  if (\r\n    // In legacy mode, we commit the primary tree as if it successfully\r\n    // completed, even though it's in an inconsistent state.\r\n    (mode & BlockingMode) === NoMode &&\r\n    // Make sure we're on the second pass, i.e. the primary child fragment was\r\n    // already cloned. In legacy mode, the only case where this isn't true is\r\n    // when DevTools forces us to display a fallback; we skip the first render\r\n    // pass entirely and go straight to rendering the fallback. (In Concurrent\r\n    // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\r\n    // only codepath.)\r\n    workInProgress.child !== currentPrimaryChildFragment\r\n  ) {\r\n    const progressedPrimaryFragment: Fiber = (workInProgress.child: any);\r\n    primaryChildFragment = progressedPrimaryFragment;\r\n    primaryChildFragment.childLanes = NoLanes;\r\n    primaryChildFragment.pendingProps = primaryChildProps;\r\n\r\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\r\n      // Reset the durations from the first pass so they aren't included in the\r\n      // final amounts. This seems counterintuitive, since we're intentionally\r\n      // not measuring part of the render phase, but this makes it match what we\r\n      // do in Concurrent Mode.\r\n      primaryChildFragment.actualDuration = 0;\r\n      primaryChildFragment.actualStartTime = -1;\r\n      primaryChildFragment.selfBaseDuration =\r\n        currentPrimaryChildFragment.selfBaseDuration;\r\n      primaryChildFragment.treeBaseDuration =\r\n        currentPrimaryChildFragment.treeBaseDuration;\r\n    }\r\n\r\n    // The fallback fiber was added as a deletion effect during the first pass.\r\n    // However, since we're going to remain on the fallback, we no longer want\r\n    // to delete it. So we need to remove it from the list. Deletions are stored\r\n    // on the same list as effects. We want to keep the effects from the primary\r\n    // tree. So we copy the primary child fragment's effect list, which does not\r\n    // include the fallback deletion effect.\r\n    const progressedLastEffect = primaryChildFragment.lastEffect;\r\n    if (progressedLastEffect !== null) {\r\n      workInProgress.firstEffect = primaryChildFragment.firstEffect;\r\n      workInProgress.lastEffect = progressedLastEffect;\r\n      progressedLastEffect.nextEffect = null;\r\n    } else {\r\n      // TODO: Reset this somewhere else? Lol legacy mode is so weird.\r\n      workInProgress.firstEffect = workInProgress.lastEffect = null;\r\n    }\r\n  } else {\r\n    primaryChildFragment = createWorkInProgressOffscreenFiber(\r\n      currentPrimaryChildFragment,\r\n      primaryChildProps,\r\n    );\r\n  }\r\n  let fallbackChildFragment;\r\n  if (currentFallbackChildFragment !== null) {\r\n    fallbackChildFragment = createWorkInProgress(\r\n      currentFallbackChildFragment,\r\n      fallbackChildren,\r\n    );\r\n  } else {\r\n    fallbackChildFragment = createFiberFromFragment(\r\n      fallbackChildren,\r\n      mode,\r\n      renderLanes,\r\n      null,\r\n    );\r\n    // Needs a placement effect because the parent (the Suspense boundary) already\r\n    // mounted but this is a new fiber.\r\n    fallbackChildFragment.flags |= Placement;\r\n  }\r\n\r\n  fallbackChildFragment.return = workInProgress;\r\n  primaryChildFragment.return = workInProgress;\r\n  primaryChildFragment.sibling = fallbackChildFragment;\r\n  workInProgress.child = primaryChildFragment;\r\n\r\n  return fallbackChildFragment;\r\n}\r\n\r\nfunction retrySuspenseComponentWithoutHydrating(\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  // This will add the old fiber to the deletion list\r\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\r\n\r\n  // We're now not suspended nor dehydrated.\r\n  const nextProps = workInProgress.pendingProps;\r\n  const primaryChildren = nextProps.children;\r\n  const primaryChildFragment = mountSuspensePrimaryChildren(\r\n    workInProgress,\r\n    primaryChildren,\r\n    renderLanes,\r\n  );\r\n  // Needs a placement effect because the parent (the Suspense boundary) already\r\n  // mounted but this is a new fiber.\r\n  primaryChildFragment.flags |= Placement;\r\n  workInProgress.memoizedState = null;\r\n\r\n  return primaryChildFragment;\r\n}\r\n\r\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(\r\n  current,\r\n  workInProgress,\r\n  primaryChildren,\r\n  fallbackChildren,\r\n  renderLanes,\r\n) {\r\n  const mode = workInProgress.mode;\r\n  const primaryChildFragment = createFiberFromOffscreen(\r\n    primaryChildren,\r\n    mode,\r\n    NoLanes,\r\n    null,\r\n  );\r\n  const fallbackChildFragment = createFiberFromFragment(\r\n    fallbackChildren,\r\n    mode,\r\n    renderLanes,\r\n    null,\r\n  );\r\n  // Needs a placement effect because the parent (the Suspense\r\n  // boundary) already mounted but this is a new fiber.\r\n  fallbackChildFragment.flags |= Placement;\r\n\r\n  primaryChildFragment.return = workInProgress;\r\n  fallbackChildFragment.return = workInProgress;\r\n  primaryChildFragment.sibling = fallbackChildFragment;\r\n  workInProgress.child = primaryChildFragment;\r\n\r\n  if ((workInProgress.mode & BlockingMode) !== NoMode) {\r\n    // We will have dropped the effect list which contains the\r\n    // deletion. We need to reconcile to delete the current child.\r\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\r\n  }\r\n\r\n  return fallbackChildFragment;\r\n}\r\n\r\nfunction mountDehydratedSuspenseComponent(\r\n  workInProgress: Fiber,\r\n  suspenseInstance: SuspenseInstance,\r\n  renderLanes: Lanes,\r\n): null | Fiber {\r\n  // During the first pass, we'll bail out and not drill into the children.\r\n  // Instead, we'll leave the content in place and try to hydrate it later.\r\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'Cannot hydrate Suspense in legacy mode. Switch from ' +\r\n          'ReactDOM.hydrate(element, container) to ' +\r\n          'ReactDOM.createBlockingRoot(container, { hydrate: true })' +\r\n          '.render(element) or remove the Suspense components from ' +\r\n          'the server rendered components.',\r\n      );\r\n    }\r\n    workInProgress.lanes = laneToLanes(SyncLane);\r\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\r\n    // This is a client-only boundary. Since we won't get any content from the server\r\n    // for this, we need to schedule that at a higher priority based on when it would\r\n    // have timed out. In theory we could render it in this pass but it would have the\r\n    // wrong priority associated with it and will prevent hydration of parent path.\r\n    // Instead, we'll leave work left on it to render it in a separate commit.\r\n\r\n    // TODO This time should be the time at which the server rendered response that is\r\n    // a parent to this boundary was displayed. However, since we currently don't have\r\n    // a protocol to transfer that time, we'll just estimate it by using the current\r\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\r\n    // they should be.\r\n    // Schedule a normal pri update to render this content.\r\n    if (enableSchedulerTracing) {\r\n      markSpawnedWork(DefaultHydrationLane);\r\n    }\r\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\r\n  } else {\r\n    // We'll continue hydrating the rest at offscreen priority since we'll already\r\n    // be showing the right content coming from the server, it is no rush.\r\n    workInProgress.lanes = laneToLanes(OffscreenLane);\r\n    if (enableSchedulerTracing) {\r\n      markSpawnedWork(OffscreenLane);\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction updateDehydratedSuspenseComponent(\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  suspenseInstance: SuspenseInstance,\r\n  suspenseState: SuspenseState,\r\n  renderLanes: Lanes,\r\n): null | Fiber {\r\n  // We should never be hydrating at this point because it is the first pass,\r\n  // but after we've already committed once.\r\n  warnIfHydrating();\r\n\r\n  if ((getExecutionContext() & RetryAfterError) !== NoContext) {\r\n    return retrySuspenseComponentWithoutHydrating(\r\n      current,\r\n      workInProgress,\r\n      renderLanes,\r\n    );\r\n  }\r\n\r\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\r\n    return retrySuspenseComponentWithoutHydrating(\r\n      current,\r\n      workInProgress,\r\n      renderLanes,\r\n    );\r\n  }\r\n\r\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\r\n    // This boundary is in a permanent fallback state. In this case, we'll never\r\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\r\n    // client side render instead.\r\n    return retrySuspenseComponentWithoutHydrating(\r\n      current,\r\n      workInProgress,\r\n      renderLanes,\r\n    );\r\n  }\r\n  // We use lanes to indicate that a child might depend on context, so if\r\n  // any context has changed, we need to treat is as if the input might have changed.\r\n  const hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\r\n  if (didReceiveUpdate || hasContextChanged) {\r\n    // This boundary has changed since the first render. This means that we are now unable to\r\n    // hydrate it. We might still be able to hydrate it using a higher priority lane.\r\n    const root = getWorkInProgressRoot();\r\n    if (root !== null) {\r\n      const attemptHydrationAtLane = getBumpedLaneForHydration(\r\n        root,\r\n        renderLanes,\r\n      );\r\n      if (\r\n        attemptHydrationAtLane !== NoLane &&\r\n        attemptHydrationAtLane !== suspenseState.retryLane\r\n      ) {\r\n        // Intentionally mutating since this render will get interrupted. This\r\n        // is one of the very rare times where we mutate the current tree\r\n        // during the render phase.\r\n        suspenseState.retryLane = attemptHydrationAtLane;\r\n        // TODO: Ideally this would inherit the event time of the current render\r\n        const eventTime = NoTimestamp;\r\n        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\r\n      } else {\r\n        // We have already tried to ping at a higher priority than we're rendering with\r\n        // so if we got here, we must have failed to hydrate at those levels. We must\r\n        // now give up. Instead, we're going to delete the whole subtree and instead inject\r\n        // a new real Suspense boundary to take its place, which may render content\r\n        // or fallback. This might suspend for a while and if it does we might still have\r\n        // an opportunity to hydrate before this pass commits.\r\n      }\r\n    }\r\n\r\n    // If we have scheduled higher pri work above, this will probably just abort the render\r\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\r\n    // render something, if we time out. Even if that requires us to delete everything and\r\n    // skip hydration.\r\n    // Delay having to do this as long as the suspense timeout allows us.\r\n    renderDidSuspendDelayIfPossible();\r\n    return retrySuspenseComponentWithoutHydrating(\r\n      current,\r\n      workInProgress,\r\n      renderLanes,\r\n    );\r\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\r\n    // This component is still pending more data from the server, so we can't hydrate its\r\n    // content. We treat it as if this component suspended itself. It might seem as if\r\n    // we could just try to render it client-side instead. However, this will perform a\r\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\r\n    // on missing data anyway. Additionally, the server might be able to render more\r\n    // than we can on the client yet. In that case we'd end up with more fallback states\r\n    // on the client than if we just leave it alone. If the server times out or errors\r\n    // these should update this boundary to the permanent Fallback state instead.\r\n    // Mark it as having captured (i.e. suspended).\r\n    workInProgress.flags |= DidCapture;\r\n    // Leave the child in place. I.e. the dehydrated fragment.\r\n    workInProgress.child = current.child;\r\n    // Register a callback to retry this boundary once the server has sent the result.\r\n    let retry = retryDehydratedSuspenseBoundary.bind(null, current);\r\n    if (enableSchedulerTracing) {\r\n      retry = Schedule_tracing_wrap(retry);\r\n    }\r\n    registerSuspenseInstanceRetry(suspenseInstance, retry);\r\n    return null;\r\n  } else {\r\n    // This is the first attempt.\r\n    reenterHydrationStateFromDehydratedSuspenseInstance(\r\n      workInProgress,\r\n      suspenseInstance,\r\n    );\r\n    const nextProps = workInProgress.pendingProps;\r\n    const primaryChildren = nextProps.children;\r\n    const primaryChildFragment = mountSuspensePrimaryChildren(\r\n      workInProgress,\r\n      primaryChildren,\r\n      renderLanes,\r\n    );\r\n    // Mark the children as hydrating. This is a fast path to know whether this\r\n    // tree is part of a hydrating tree. This is used to determine if a child\r\n    // node has fully mounted yet, and for scheduling event replaying.\r\n    // Conceptually this is similar to Placement in that a new subtree is\r\n    // inserted into the React tree here. It just happens to not need DOM\r\n    // mutations because it already exists.\r\n    primaryChildFragment.flags |= Hydrating;\r\n    return primaryChildFragment;\r\n  }\r\n}\r\n\r\nfunction scheduleWorkOnFiber(fiber: Fiber, renderLanes: Lanes) {\r\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\r\n  const alternate = fiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\r\n  }\r\n  scheduleWorkOnParentPath(fiber.return, renderLanes);\r\n}\r\n\r\nfunction propagateSuspenseContextChange(\r\n  workInProgress: Fiber,\r\n  firstChild: null | Fiber,\r\n  renderLanes: Lanes,\r\n): void {\r\n  // Mark any Suspense boundaries with fallbacks as having work to do.\r\n  // If they were previously forced into fallbacks, they may now be able\r\n  // to unblock.\r\n  let node = firstChild;\r\n  while (node !== null) {\r\n    if (node.tag === SuspenseComponent) {\r\n      const state: SuspenseState | null = node.memoizedState;\r\n      if (state !== null) {\r\n        scheduleWorkOnFiber(node, renderLanes);\r\n      }\r\n    } else if (node.tag === SuspenseListComponent) {\r\n      // If the tail is hidden there might not be an Suspense boundaries\r\n      // to schedule work on. In this case we have to schedule it on the\r\n      // list itself.\r\n      // We don't have to traverse to the children of the list since\r\n      // the list will propagate the change when it rerenders.\r\n      scheduleWorkOnFiber(node, renderLanes);\r\n    } else if (node.child !== null) {\r\n      node.child.return = node;\r\n      node = node.child;\r\n      continue;\r\n    }\r\n    if (node === workInProgress) {\r\n      return;\r\n    }\r\n    while (node.sibling === null) {\r\n      if (node.return === null || node.return === workInProgress) {\r\n        return;\r\n      }\r\n      node = node.return;\r\n    }\r\n    node.sibling.return = node.return;\r\n    node = node.sibling;\r\n  }\r\n}\r\n\r\nfunction findLastContentRow(firstChild: null | Fiber): null | Fiber {\r\n  // This is going to find the last row among these children that is already\r\n  // showing content on the screen, as opposed to being in fallback state or\r\n  // new. If a row has multiple Suspense boundaries, any of them being in the\r\n  // fallback state, counts as the whole row being in a fallback state.\r\n  // Note that the \"rows\" will be workInProgress, but any nested children\r\n  // will still be current since we haven't rendered them yet. The mounted\r\n  // order may not be the same as the new order. We use the new order.\r\n  let row = firstChild;\r\n  let lastContentRow: null | Fiber = null;\r\n  while (row !== null) {\r\n    const currentRow = row.alternate;\r\n    // New rows can't be content rows.\r\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\r\n      lastContentRow = row;\r\n    }\r\n    row = row.sibling;\r\n  }\r\n  return lastContentRow;\r\n}\r\n\r\ntype SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void;\r\n\r\nfunction validateRevealOrder(revealOrder: SuspenseListRevealOrder) {\r\n  if (__DEV__) {\r\n    if (\r\n      revealOrder !== undefined &&\r\n      revealOrder !== 'forwards' &&\r\n      revealOrder !== 'backwards' &&\r\n      revealOrder !== 'together' &&\r\n      !didWarnAboutRevealOrder[revealOrder]\r\n    ) {\r\n      didWarnAboutRevealOrder[revealOrder] = true;\r\n      if (typeof revealOrder === 'string') {\r\n        switch (revealOrder.toLowerCase()) {\r\n          case 'together':\r\n          case 'forwards':\r\n          case 'backwards': {\r\n            console.error(\r\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\r\n                'Use lowercase \"%s\" instead.',\r\n              revealOrder,\r\n              revealOrder.toLowerCase(),\r\n            );\r\n            break;\r\n          }\r\n          case 'forward':\r\n          case 'backward': {\r\n            console.error(\r\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\r\n                'React uses the -s suffix in the spelling. Use \"%ss\" instead.',\r\n              revealOrder,\r\n              revealOrder.toLowerCase(),\r\n            );\r\n            break;\r\n          }\r\n          default:\r\n            console.error(\r\n              '\"%s\" is not a supported revealOrder on <SuspenseList />. ' +\r\n                'Did you mean \"together\", \"forwards\" or \"backwards\"?',\r\n              revealOrder,\r\n            );\r\n            break;\r\n        }\r\n      } else {\r\n        console.error(\r\n          '%s is not a supported value for revealOrder on <SuspenseList />. ' +\r\n            'Did you mean \"together\", \"forwards\" or \"backwards\"?',\r\n          revealOrder,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateTailOptions(\r\n  tailMode: SuspenseListTailMode,\r\n  revealOrder: SuspenseListRevealOrder,\r\n) {\r\n  if (__DEV__) {\r\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\r\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\r\n        didWarnAboutTailOptions[tailMode] = true;\r\n        console.error(\r\n          '\"%s\" is not a supported value for tail on <SuspenseList />. ' +\r\n            'Did you mean \"collapsed\" or \"hidden\"?',\r\n          tailMode,\r\n        );\r\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\r\n        didWarnAboutTailOptions[tailMode] = true;\r\n        console.error(\r\n          '<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' +\r\n            '\"forwards\" or \"backwards\". ' +\r\n            'Did you mean to specify revealOrder=\"forwards\"?',\r\n          tailMode,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateSuspenseListNestedChild(childSlot: mixed, index: number) {\r\n  if (__DEV__) {\r\n    const isArray = Array.isArray(childSlot);\r\n    const isIterable =\r\n      !isArray && typeof getIteratorFn(childSlot) === 'function';\r\n    if (isArray || isIterable) {\r\n      const type = isArray ? 'array' : 'iterable';\r\n      console.error(\r\n        'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +\r\n          'an additional SuspenseList to configure its revealOrder: ' +\r\n          '<SuspenseList revealOrder=...> ... ' +\r\n          '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' +\r\n          '</SuspenseList>',\r\n        type,\r\n        index,\r\n        type,\r\n      );\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction validateSuspenseListChildren(\r\n  children: mixed,\r\n  revealOrder: SuspenseListRevealOrder,\r\n) {\r\n  if (__DEV__) {\r\n    if (\r\n      (revealOrder === 'forwards' || revealOrder === 'backwards') &&\r\n      children !== undefined &&\r\n      children !== null &&\r\n      children !== false\r\n    ) {\r\n      if (Array.isArray(children)) {\r\n        for (let i = 0; i < children.length; i++) {\r\n          if (!validateSuspenseListNestedChild(children[i], i)) {\r\n            return;\r\n          }\r\n        }\r\n      } else {\r\n        const iteratorFn = getIteratorFn(children);\r\n        if (typeof iteratorFn === 'function') {\r\n          const childrenIterator = iteratorFn.call(children);\r\n          if (childrenIterator) {\r\n            let step = childrenIterator.next();\r\n            let i = 0;\r\n            for (; !step.done; step = childrenIterator.next()) {\r\n              if (!validateSuspenseListNestedChild(step.value, i)) {\r\n                return;\r\n              }\r\n              i++;\r\n            }\r\n          }\r\n        } else {\r\n          console.error(\r\n            'A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' +\r\n              'This is not useful since it needs multiple rows. ' +\r\n              'Did you mean to pass multiple children or an array?',\r\n            revealOrder,\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction initSuspenseListRenderState(\r\n  workInProgress: Fiber,\r\n  isBackwards: boolean,\r\n  tail: null | Fiber,\r\n  lastContentRow: null | Fiber,\r\n  tailMode: SuspenseListTailMode,\r\n  lastEffectBeforeRendering: null | Fiber,\r\n): void {\r\n  const renderState: null | SuspenseListRenderState =\r\n    workInProgress.memoizedState;\r\n  if (renderState === null) {\r\n    workInProgress.memoizedState = ({\r\n      isBackwards: isBackwards,\r\n      rendering: null,\r\n      renderingStartTime: 0,\r\n      last: lastContentRow,\r\n      tail: tail,\r\n      tailMode: tailMode,\r\n      lastEffect: lastEffectBeforeRendering,\r\n    }: SuspenseListRenderState);\r\n  } else {\r\n    // We can reuse the existing object from previous renders.\r\n    renderState.isBackwards = isBackwards;\r\n    renderState.rendering = null;\r\n    renderState.renderingStartTime = 0;\r\n    renderState.last = lastContentRow;\r\n    renderState.tail = tail;\r\n    renderState.tailMode = tailMode;\r\n    renderState.lastEffect = lastEffectBeforeRendering;\r\n  }\r\n}\r\n\r\n// This can end up rendering this component multiple passes.\r\n// The first pass splits the children fibers into two sets. A head and tail.\r\n// We first render the head. If anything is in fallback state, we do another\r\n// pass through beginWork to rerender all children (including the tail) with\r\n// the force suspend context. If the first render didn't have anything in\r\n// in fallback state. Then we render each row in the tail one-by-one.\r\n// That happens in the completeWork phase without going back to beginWork.\r\nfunction updateSuspenseListComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const nextProps = workInProgress.pendingProps;\r\n  const revealOrder: SuspenseListRevealOrder = nextProps.revealOrder;\r\n  const tailMode: SuspenseListTailMode = nextProps.tail;\r\n  const newChildren = nextProps.children;\r\n\r\n  validateRevealOrder(revealOrder);\r\n  validateTailOptions(tailMode, revealOrder);\r\n  validateSuspenseListChildren(newChildren, revealOrder);\r\n\r\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n\r\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\r\n\r\n  const shouldForceFallback = hasSuspenseContext(\r\n    suspenseContext,\r\n    (ForceSuspenseFallback: SuspenseContext),\r\n  );\r\n  if (shouldForceFallback) {\r\n    suspenseContext = setShallowSuspenseContext(\r\n      suspenseContext,\r\n      ForceSuspenseFallback,\r\n    );\r\n    workInProgress.flags |= DidCapture;\r\n  } else {\r\n    const didSuspendBefore =\r\n      current !== null && (current.flags & DidCapture) !== NoFlags;\r\n    if (didSuspendBefore) {\r\n      // If we previously forced a fallback, we need to schedule work\r\n      // on any nested boundaries to let them know to try to render\r\n      // again. This is the same as context updating.\r\n      propagateSuspenseContextChange(\r\n        workInProgress,\r\n        workInProgress.child,\r\n        renderLanes,\r\n      );\r\n    }\r\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n  }\r\n  pushSuspenseContext(workInProgress, suspenseContext);\r\n\r\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\r\n    // In legacy mode, SuspenseList doesn't work so we just\r\n    // use make it a noop by treating it as the default revealOrder.\r\n    workInProgress.memoizedState = null;\r\n  } else {\r\n    switch (revealOrder) {\r\n      case 'forwards': {\r\n        const lastContentRow = findLastContentRow(workInProgress.child);\r\n        let tail;\r\n        if (lastContentRow === null) {\r\n          // The whole list is part of the tail.\r\n          // TODO: We could fast path by just rendering the tail now.\r\n          tail = workInProgress.child;\r\n          workInProgress.child = null;\r\n        } else {\r\n          // Disconnect the tail rows after the content row.\r\n          // We're going to render them separately later.\r\n          tail = lastContentRow.sibling;\r\n          lastContentRow.sibling = null;\r\n        }\r\n        initSuspenseListRenderState(\r\n          workInProgress,\r\n          false, // isBackwards\r\n          tail,\r\n          lastContentRow,\r\n          tailMode,\r\n          workInProgress.lastEffect,\r\n        );\r\n        break;\r\n      }\r\n      case 'backwards': {\r\n        // We're going to find the first row that has existing content.\r\n        // At the same time we're going to reverse the list of everything\r\n        // we pass in the meantime. That's going to be our tail in reverse\r\n        // order.\r\n        let tail = null;\r\n        let row = workInProgress.child;\r\n        workInProgress.child = null;\r\n        while (row !== null) {\r\n          const currentRow = row.alternate;\r\n          // New rows can't be content rows.\r\n          if (currentRow !== null && findFirstSuspended(currentRow) === null) {\r\n            // This is the beginning of the main content.\r\n            workInProgress.child = row;\r\n            break;\r\n          }\r\n          const nextRow = row.sibling;\r\n          row.sibling = tail;\r\n          tail = row;\r\n          row = nextRow;\r\n        }\r\n        // TODO: If workInProgress.child is null, we can continue on the tail immediately.\r\n        initSuspenseListRenderState(\r\n          workInProgress,\r\n          true, // isBackwards\r\n          tail,\r\n          null, // last\r\n          tailMode,\r\n          workInProgress.lastEffect,\r\n        );\r\n        break;\r\n      }\r\n      case 'together': {\r\n        initSuspenseListRenderState(\r\n          workInProgress,\r\n          false, // isBackwards\r\n          null, // tail\r\n          null, // last\r\n          undefined,\r\n          workInProgress.lastEffect,\r\n        );\r\n        break;\r\n      }\r\n      default: {\r\n        // The default reveal order is the same as not having\r\n        // a boundary.\r\n        workInProgress.memoizedState = null;\r\n      }\r\n    }\r\n  }\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updatePortalComponent(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\r\n  const nextChildren = workInProgress.pendingProps;\r\n  if (current === null) {\r\n    // Portals are special because we don't append the children during mount\r\n    // but at commit. Therefore we need to track insertions which the normal\r\n    // flow doesn't do during mount. This doesn't happen at the root because\r\n    // the root always starts with a \"current\" with a null child.\r\n    // TODO: Consider unifying this with how the root works.\r\n    workInProgress.child = reconcileChildFibers(\r\n      workInProgress,\r\n      null,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  }\r\n  return workInProgress.child;\r\n}\r\n\r\nlet hasWarnedAboutUsingNoValuePropOnContextProvider = false;\r\n\r\nfunction updateContextProvider(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const providerType: ReactProviderType<any> = workInProgress.type;\r\n  const context: ReactContext<any> = providerType._context;\r\n\r\n  const newProps = workInProgress.pendingProps;\r\n  const oldProps = workInProgress.memoizedProps;\r\n\r\n  const newValue = newProps.value;\r\n\r\n  if (__DEV__) {\r\n    if (!('value' in newProps)) {\r\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\r\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\r\n        console.error(\r\n          'The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?',\r\n        );\r\n      }\r\n    }\r\n    const providerPropTypes = workInProgress.type.propTypes;\r\n\r\n    if (providerPropTypes) {\r\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\r\n    }\r\n  }\r\n\r\n  pushProvider(workInProgress, newValue);\r\n\r\n  if (oldProps !== null) {\r\n    const oldValue = oldProps.value;\r\n    const changedBits = calculateChangedBits(context, newValue, oldValue);\r\n    if (changedBits === 0) {\r\n      // No change. Bailout early if children are the same.\r\n      if (\r\n        oldProps.children === newProps.children &&\r\n        !hasLegacyContextChanged()\r\n      ) {\r\n        return bailoutOnAlreadyFinishedWork(\r\n          current,\r\n          workInProgress,\r\n          renderLanes,\r\n        );\r\n      }\r\n    } else {\r\n      // The context value changed. Search for matching consumers and schedule\r\n      // them to update.\r\n      propagateContextChange(workInProgress, context, changedBits, renderLanes);\r\n    }\r\n  }\r\n\r\n  const newChildren = newProps.children;\r\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nlet hasWarnedAboutUsingContextAsConsumer = false;\r\n\r\nfunction updateContextConsumer(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  let context: ReactContext<any> = workInProgress.type;\r\n  // The logic below for Context differs depending on PROD or DEV mode. In\r\n  // DEV mode, we create a separate object for Context.Consumer that acts\r\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\r\n  // so we use the old behaviour (Context.Consumer references Context) to\r\n  // reduce size and overhead. The separate object references context via\r\n  // a property called \"_context\", which also gives us the ability to check\r\n  // in DEV mode if this property exists or not and warn if it does not.\r\n  if (__DEV__) {\r\n    if ((context: any)._context === undefined) {\r\n      // This may be because it's a Context (rather than a Consumer).\r\n      // Or it may be because it's older React where they're the same thing.\r\n      // We only want to warn if we're sure it's a new React.\r\n      if (context !== context.Consumer) {\r\n        if (!hasWarnedAboutUsingContextAsConsumer) {\r\n          hasWarnedAboutUsingContextAsConsumer = true;\r\n          console.error(\r\n            'Rendering <Context> directly is not supported and will be removed in ' +\r\n              'a future major release. Did you mean to render <Context.Consumer> instead?',\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      context = (context: any)._context;\r\n    }\r\n  }\r\n  const newProps = workInProgress.pendingProps;\r\n  const render = newProps.children;\r\n\r\n  if (__DEV__) {\r\n    if (typeof render !== 'function') {\r\n      console.error(\r\n        'A context consumer was rendered with multiple children, or a child ' +\r\n          \"that isn't a function. A context consumer expects a single child \" +\r\n          'that is a function. If you did pass a function, make sure there ' +\r\n          'is no trailing or leading whitespace around it.',\r\n      );\r\n    }\r\n  }\r\n\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  const newValue = readContext(context, newProps.unstable_observedBits);\r\n  let newChildren;\r\n  if (__DEV__) {\r\n    ReactCurrentOwner.current = workInProgress;\r\n    setIsRendering(true);\r\n    newChildren = render(newValue);\r\n    setIsRendering(false);\r\n  } else {\r\n    newChildren = render(newValue);\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateFundamentalComponent(current, workInProgress, renderLanes) {\r\n  const fundamentalImpl = workInProgress.type.impl;\r\n  if (fundamentalImpl.reconcileChildren === false) {\r\n    return null;\r\n  }\r\n  const nextProps = workInProgress.pendingProps;\r\n  const nextChildren = nextProps.children;\r\n\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateScopeComponent(current, workInProgress, renderLanes) {\r\n  const nextProps = workInProgress.pendingProps;\r\n  const nextChildren = nextProps.children;\r\n\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nexport function markWorkInProgressReceivedUpdate() {\r\n  didReceiveUpdate = true;\r\n}\r\n\r\nfunction bailoutOnAlreadyFinishedWork(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n): Fiber | null {\r\n  if (current !== null) {\r\n    // Reuse previous dependencies\r\n    workInProgress.dependencies = current.dependencies;\r\n  }\r\n\r\n  if (enableProfilerTimer) {\r\n    // Don't update \"base\" render times for bailouts.\r\n    stopProfilerTimerIfRunning(workInProgress);\r\n  }\r\n\r\n  markSkippedUpdateLanes(workInProgress.lanes);\r\n\r\n  // Check if the children have any pending work.\r\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\r\n    // The children don't have any work either. We can skip them.\r\n    // TODO: Once we add back resuming, we should check if the children are\r\n    // a work-in-progress set. If so, we need to transfer their effects.\r\n    return null;\r\n  } else {\r\n    // This fiber doesn't have work, but its subtree does. Clone the child\r\n    // fibers and continue.\r\n    cloneChildFibers(current, workInProgress);\r\n    return workInProgress.child;\r\n  }\r\n}\r\n\r\nfunction remountFiber(\r\n  current: Fiber,\r\n  oldWorkInProgress: Fiber,\r\n  newWorkInProgress: Fiber,\r\n): Fiber | null {\r\n  if (__DEV__) {\r\n    const returnFiber = oldWorkInProgress.return;\r\n    if (returnFiber === null) {\r\n      throw new Error('Cannot swap the root fiber.');\r\n    }\r\n\r\n    // Disconnect from the old current.\r\n    // It will get deleted.\r\n    current.alternate = null;\r\n    oldWorkInProgress.alternate = null;\r\n\r\n    // Connect to the new tree.\r\n    newWorkInProgress.index = oldWorkInProgress.index;\r\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\r\n    newWorkInProgress.return = oldWorkInProgress.return;\r\n    newWorkInProgress.ref = oldWorkInProgress.ref;\r\n\r\n    // Replace the child/sibling pointers above it.\r\n    if (oldWorkInProgress === returnFiber.child) {\r\n      returnFiber.child = newWorkInProgress;\r\n    } else {\r\n      let prevSibling = returnFiber.child;\r\n      if (prevSibling === null) {\r\n        throw new Error('Expected parent to have a child.');\r\n      }\r\n      while (prevSibling.sibling !== oldWorkInProgress) {\r\n        prevSibling = prevSibling.sibling;\r\n        if (prevSibling === null) {\r\n          throw new Error('Expected to find the previous sibling.');\r\n        }\r\n      }\r\n      prevSibling.sibling = newWorkInProgress;\r\n    }\r\n\r\n    // Delete the old fiber and place the new one.\r\n    // Since the old fiber is disconnected, we have to schedule it manually.\r\n    const last = returnFiber.lastEffect;\r\n    if (last !== null) {\r\n      last.nextEffect = current;\r\n      returnFiber.lastEffect = current;\r\n    } else {\r\n      returnFiber.firstEffect = returnFiber.lastEffect = current;\r\n    }\r\n    current.nextEffect = null;\r\n    current.flags = Deletion;\r\n\r\n    newWorkInProgress.flags |= Placement;\r\n\r\n    // Restart work from the new fiber.\r\n    return newWorkInProgress;\r\n  } else {\r\n    throw new Error(\r\n      'Did not expect this call in production. ' +\r\n        'This is a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n}\r\n\r\nfunction beginWork(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n): Fiber | null {\r\n  const updateLanes = workInProgress.lanes;\r\n\r\n  if (__DEV__) {\r\n    if (workInProgress._debugNeedsRemount && current !== null) {\r\n      // This will restart the begin phase with a new fiber.\r\n      return remountFiber(\r\n        current,\r\n        workInProgress,\r\n        createFiberFromTypeAndProps(\r\n          workInProgress.type,\r\n          workInProgress.key,\r\n          workInProgress.pendingProps,\r\n          workInProgress._debugOwner || null,\r\n          workInProgress.mode,\r\n          workInProgress.lanes,\r\n        ),\r\n      );\r\n    }\r\n  }\r\n\r\n  if (current !== null) {\r\n    const oldProps = current.memoizedProps;\r\n    const newProps = workInProgress.pendingProps;\r\n\r\n    if (\r\n      oldProps !== newProps ||\r\n      hasLegacyContextChanged() ||\r\n      // Force a re-render if the implementation changed due to hot reload:\r\n      (__DEV__ ? workInProgress.type !== current.type : false)\r\n    ) {\r\n      // If props or context changed, mark the fiber as having performed work.\r\n      // This may be unset if the props are determined to be equal later (memo).\r\n      didReceiveUpdate = true;\r\n    } else if (!includesSomeLane(renderLanes, updateLanes)) {\r\n      didReceiveUpdate = false;\r\n      // This fiber does not have any pending work. Bailout without entering\r\n      // the begin phase. There's still some bookkeeping we that needs to be done\r\n      // in this optimized path, mostly pushing stuff onto the stack.\r\n      switch (workInProgress.tag) {\r\n        case HostRoot:\r\n          pushHostRootContext(workInProgress);\r\n          resetHydrationState();\r\n          break;\r\n        case HostComponent:\r\n          pushHostContext(workInProgress);\r\n          break;\r\n        case ClassComponent: {\r\n          const Component = workInProgress.type;\r\n          if (isLegacyContextProvider(Component)) {\r\n            pushLegacyContextProvider(workInProgress);\r\n          }\r\n          break;\r\n        }\r\n        case HostPortal:\r\n          pushHostContainer(\r\n            workInProgress,\r\n            workInProgress.stateNode.containerInfo,\r\n          );\r\n          break;\r\n        case ContextProvider: {\r\n          const newValue = workInProgress.memoizedProps.value;\r\n          pushProvider(workInProgress, newValue);\r\n          break;\r\n        }\r\n        case Profiler:\r\n          if (enableProfilerTimer) {\r\n            // Profiler should only call onRender when one of its descendants actually rendered.\r\n            const hasChildWork = includesSomeLane(\r\n              renderLanes,\r\n              workInProgress.childLanes,\r\n            );\r\n            if (hasChildWork) {\r\n              workInProgress.flags |= Update;\r\n            }\r\n\r\n            // Reset effect durations for the next eventual effect phase.\r\n            // These are reset during render to allow the DevTools commit hook a chance to read them,\r\n            const stateNode = workInProgress.stateNode;\r\n            stateNode.effectDuration = 0;\r\n            stateNode.passiveEffectDuration = 0;\r\n          }\r\n          break;\r\n        case SuspenseComponent: {\r\n          const state: SuspenseState | null = workInProgress.memoizedState;\r\n          if (state !== null) {\r\n            if (enableSuspenseServerRenderer) {\r\n              if (state.dehydrated !== null) {\r\n                pushSuspenseContext(\r\n                  workInProgress,\r\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\r\n                );\r\n                // We know that this component will suspend again because if it has\r\n                // been unsuspended it has committed as a resolved Suspense component.\r\n                // If it needs to be retried, it should have work scheduled on it.\r\n                workInProgress.flags |= DidCapture;\r\n                // We should never render the children of a dehydrated boundary until we\r\n                // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\r\n                return null;\r\n              }\r\n            }\r\n\r\n            // If this boundary is currently timed out, we need to decide\r\n            // whether to retry the primary children, or to skip over it and\r\n            // go straight to the fallback. Check the priority of the primary\r\n            // child fragment.\r\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n            const primaryChildLanes = primaryChildFragment.childLanes;\r\n            if (includesSomeLane(renderLanes, primaryChildLanes)) {\r\n              // The primary children have pending work. Use the normal path\r\n              // to attempt to render the primary children again.\r\n              return updateSuspenseComponent(\r\n                current,\r\n                workInProgress,\r\n                renderLanes,\r\n              );\r\n            } else {\r\n              // The primary child fragment does not have pending work marked\r\n              // on it\r\n              pushSuspenseContext(\r\n                workInProgress,\r\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\r\n              );\r\n              // The primary children do not have pending work with sufficient\r\n              // priority. Bailout.\r\n              const child = bailoutOnAlreadyFinishedWork(\r\n                current,\r\n                workInProgress,\r\n                renderLanes,\r\n              );\r\n              if (child !== null) {\r\n                // The fallback children have pending work. Skip over the\r\n                // primary children and work on the fallback.\r\n                return child.sibling;\r\n              } else {\r\n                return null;\r\n              }\r\n            }\r\n          } else {\r\n            pushSuspenseContext(\r\n              workInProgress,\r\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case SuspenseListComponent: {\r\n          const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\r\n\r\n          const hasChildWork = includesSomeLane(\r\n            renderLanes,\r\n            workInProgress.childLanes,\r\n          );\r\n\r\n          if (didSuspendBefore) {\r\n            if (hasChildWork) {\r\n              // If something was in fallback state last time, and we have all the\r\n              // same children then we're still in progressive loading state.\r\n              // Something might get unblocked by state updates or retries in the\r\n              // tree which will affect the tail. So we need to use the normal\r\n              // path to compute the correct tail.\r\n              return updateSuspenseListComponent(\r\n                current,\r\n                workInProgress,\r\n                renderLanes,\r\n              );\r\n            }\r\n            // If none of the children had any work, that means that none of\r\n            // them got retried so they'll still be blocked in the same way\r\n            // as before. We can fast bail out.\r\n            workInProgress.flags |= DidCapture;\r\n          }\r\n\r\n          // If nothing suspended before and we're rendering the same children,\r\n          // then the tail doesn't matter. Anything new that suspends will work\r\n          // in the \"together\" mode, so we can continue from the state we had.\r\n          const renderState = workInProgress.memoizedState;\r\n          if (renderState !== null) {\r\n            // Reset to the \"together\" mode in case we've started a different\r\n            // update in the past but didn't complete it.\r\n            renderState.rendering = null;\r\n            renderState.tail = null;\r\n            renderState.lastEffect = null;\r\n          }\r\n          pushSuspenseContext(workInProgress, suspenseStackCursor.current);\r\n\r\n          if (hasChildWork) {\r\n            break;\r\n          } else {\r\n            // If none of the children had any work, that means that none of\r\n            // them got retried so they'll still be blocked in the same way\r\n            // as before. We can fast bail out.\r\n            return null;\r\n          }\r\n        }\r\n        case OffscreenComponent:\r\n        case LegacyHiddenComponent: {\r\n          // Need to check if the tree still needs to be deferred. This is\r\n          // almost identical to the logic used in the normal update path,\r\n          // so we'll just enter that. The only difference is we'll bail out\r\n          // at the next level instead of this one, because the child props\r\n          // have not changed. Which is fine.\r\n          // TODO: Probably should refactor `beginWork` to split the bailout\r\n          // path from the normal path. I'm tempted to do a labeled break here\r\n          // but I won't :)\r\n          workInProgress.lanes = NoLanes;\r\n          return updateOffscreenComponent(current, workInProgress, renderLanes);\r\n        }\r\n      }\r\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n    } else {\r\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\r\n        // This is a special case that only exists for legacy mode.\r\n        // See https://github.com/facebook/react/pull/19216.\r\n        didReceiveUpdate = true;\r\n      } else {\r\n        // An update was scheduled on this fiber, but there are no new props\r\n        // nor legacy context. Set this to false. If an update queue or context\r\n        // consumer produces a changed value, it will set this to true. Otherwise,\r\n        // the component will assume the children have not changed and bail out.\r\n        didReceiveUpdate = false;\r\n      }\r\n    }\r\n  } else {\r\n    didReceiveUpdate = false;\r\n  }\r\n\r\n  // Before entering the begin phase, clear pending update priority.\r\n  // TODO: This assumes that we're about to evaluate the component and process\r\n  // the update queue. However, there's an exception: SimpleMemoComponent\r\n  // sometimes bails out later in the begin phase. This indicates that we should\r\n  // move this assignment out of the common path and into each branch.\r\n  workInProgress.lanes = NoLanes;\r\n\r\n  switch (workInProgress.tag) {\r\n    case IndeterminateComponent: {\r\n      return mountIndeterminateComponent(\r\n        current,\r\n        workInProgress,\r\n        workInProgress.type,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case LazyComponent: {\r\n      const elementType = workInProgress.elementType;\r\n      return mountLazyComponent(\r\n        current,\r\n        workInProgress,\r\n        elementType,\r\n        updateLanes,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case FunctionComponent: {\r\n      const Component = workInProgress.type;\r\n      const unresolvedProps = workInProgress.pendingProps;\r\n      const resolvedProps =\r\n        workInProgress.elementType === Component\r\n          ? unresolvedProps\r\n          : resolveDefaultProps(Component, unresolvedProps);\r\n      return updateFunctionComponent(\r\n        current,\r\n        workInProgress,\r\n        Component,\r\n        resolvedProps,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case ClassComponent: {\r\n      const Component = workInProgress.type;\r\n      const unresolvedProps = workInProgress.pendingProps;\r\n      const resolvedProps =\r\n        workInProgress.elementType === Component\r\n          ? unresolvedProps\r\n          : resolveDefaultProps(Component, unresolvedProps);\r\n      return updateClassComponent(\r\n        current,\r\n        workInProgress,\r\n        Component,\r\n        resolvedProps,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case HostRoot:\r\n      return updateHostRoot(current, workInProgress, renderLanes);\r\n    case HostComponent:\r\n      return updateHostComponent(current, workInProgress, renderLanes);\r\n    case HostText:\r\n      return updateHostText(current, workInProgress);\r\n    case SuspenseComponent:\r\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\r\n    case HostPortal:\r\n      return updatePortalComponent(current, workInProgress, renderLanes);\r\n    case ForwardRef: {\r\n      const type = workInProgress.type;\r\n      const unresolvedProps = workInProgress.pendingProps;\r\n      const resolvedProps =\r\n        workInProgress.elementType === type\r\n          ? unresolvedProps\r\n          : resolveDefaultProps(type, unresolvedProps);\r\n      return updateForwardRef(\r\n        current,\r\n        workInProgress,\r\n        type,\r\n        resolvedProps,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case Fragment:\r\n      return updateFragment(current, workInProgress, renderLanes);\r\n    case Mode:\r\n      return updateMode(current, workInProgress, renderLanes);\r\n    case Profiler:\r\n      return updateProfiler(current, workInProgress, renderLanes);\r\n    case ContextProvider:\r\n      return updateContextProvider(current, workInProgress, renderLanes);\r\n    case ContextConsumer:\r\n      return updateContextConsumer(current, workInProgress, renderLanes);\r\n    case MemoComponent: {\r\n      const type = workInProgress.type;\r\n      const unresolvedProps = workInProgress.pendingProps;\r\n      // Resolve outer props first, then resolve inner props.\r\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\r\n      if (__DEV__) {\r\n        if (workInProgress.type !== workInProgress.elementType) {\r\n          const outerPropTypes = type.propTypes;\r\n          if (outerPropTypes) {\r\n            checkPropTypes(\r\n              outerPropTypes,\r\n              resolvedProps, // Resolved for outer only\r\n              'prop',\r\n              getComponentName(type),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\r\n      return updateMemoComponent(\r\n        current,\r\n        workInProgress,\r\n        type,\r\n        resolvedProps,\r\n        updateLanes,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case SimpleMemoComponent: {\r\n      return updateSimpleMemoComponent(\r\n        current,\r\n        workInProgress,\r\n        workInProgress.type,\r\n        workInProgress.pendingProps,\r\n        updateLanes,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case IncompleteClassComponent: {\r\n      const Component = workInProgress.type;\r\n      const unresolvedProps = workInProgress.pendingProps;\r\n      const resolvedProps =\r\n        workInProgress.elementType === Component\r\n          ? unresolvedProps\r\n          : resolveDefaultProps(Component, unresolvedProps);\r\n      return mountIncompleteClassComponent(\r\n        current,\r\n        workInProgress,\r\n        Component,\r\n        resolvedProps,\r\n        renderLanes,\r\n      );\r\n    }\r\n    case SuspenseListComponent: {\r\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\r\n    }\r\n    case FundamentalComponent: {\r\n      if (enableFundamentalAPI) {\r\n        return updateFundamentalComponent(current, workInProgress, renderLanes);\r\n      }\r\n      break;\r\n    }\r\n    case ScopeComponent: {\r\n      if (enableScopeAPI) {\r\n        return updateScopeComponent(current, workInProgress, renderLanes);\r\n      }\r\n      break;\r\n    }\r\n    case Block: {\r\n      if (enableBlocksAPI) {\r\n        const block = workInProgress.type;\r\n        const props = workInProgress.pendingProps;\r\n        return updateBlock(current, workInProgress, block, props, renderLanes);\r\n      }\r\n      break;\r\n    }\r\n    case OffscreenComponent: {\r\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\r\n    }\r\n    case LegacyHiddenComponent: {\r\n      return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\r\n    }\r\n  }\r\n  invariant(\r\n    false,\r\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\r\n      'React. Please file an issue.',\r\n    workInProgress.tag,\r\n  );\r\n}\r\n\r\nexport {beginWork};\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "执行完当前节点剩下的工作 然后查看时候有兄弟节点  有就返回兄弟节点  否则返回父亲节点  如此循环直到root节点",
      "line": 1670,
      "selection": {
        "start": {
          "line": 1671,
          "character": 17
        },
        "end": {
          "line": 1671,
          "character": 25
        }
      },
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "调用finishConcurrentRender  代表render阶段结束 ",
      "line": 829,
      "selection": {
        "start": {
          "line": 829,
          "character": 5
        },
        "end": {
          "line": 829,
          "character": 27
        }
      },
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "完成render  接下来开启 commit 阶段， 调用 commitRoot方法",
      "line": 841,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "获取render优先级",
      "line": 1882,
      "selection": {
        "start": {
          "line": 1883,
          "character": 5
        },
        "end": {
          "line": 1883,
          "character": 19
        }
      },
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "commit阶段的主要工作（即Renderer的工作流程）分为三部分：\nbefore mutation阶段（执行DOM操作前）\nmutation阶段（执行DOM操作）\nlayout阶段（执行DOM操作后）",
      "line": 1888,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "1. 处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。\n2. 调用getSnapshotBeforeUpdate生命周期钩子。\n3. 调度useEffect。",
      "line": 2256,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作：\n\n1. 根据ContentReset effectTag重置文字节点\n2. 更新ref\n3. 根据effectTag分别处理，其中effectTag包括(Placement | Update | Deletion | Hydrating)\n\n",
      "line": 2302,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    },
    {
      "file": "packages/react-reconciler/src/ReactFiberWorkLoop.old.js",
      "description": "commitLayoutEffects一共做了两件事：\n\n1. commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作）\n2. commitAttachRef（赋值 ref）\n\nhttps://react.iamkasong.com/renderer/layout.html#%E6%A6%82%E8%A7%88",
      "line": 2385,
      "contents": "/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane';\r\nimport type {ReactPriorityLevel} from './ReactInternalTypes';\r\nimport type {Interaction} from 'scheduler/src/Tracing';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {Effect as HookEffect} from './ReactFiberHooks.old';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  enableSuspenseServerRenderer,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableSchedulerTracing,\r\n  warnAboutUnmockedScheduler,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  decoupleUpdatePriorityFromScheduler,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport invariant from 'shared/invariant';\r\n\r\nimport {\r\n  scheduleCallback,\r\n  cancelCallback,\r\n  getCurrentPriorityLevel,\r\n  runWithPriority,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  NoPriority as NoSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  flushSyncCallbackQueue,\r\n  scheduleSyncCallback,\r\n} from './SchedulerWithReactIntegration.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\nimport {\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n} from './SchedulingProfiler';\r\n\r\n// The scheduler is imported here *only* to detect whether it's been mocked\r\nimport * as Scheduler from 'scheduler';\r\n\r\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\r\n\r\nimport {\r\n  prepareForCommit,\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  warnsIfNotActing,\r\n  beforeActiveInstanceBlur,\r\n  afterActiveInstanceBlur,\r\n  clearContainer,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport {\r\n  NoMode,\r\n  StrictMode,\r\n  ProfileMode,\r\n  BlockingMode,\r\n  ConcurrentMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Block,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  ScopeComponent,\r\n} from './ReactWorkTags';\r\nimport {LegacyRoot} from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Update,\r\n  PlacementAndUpdate,\r\n  Deletion,\r\n  Ref,\r\n  ContentReset,\r\n  Snapshot,\r\n  Callback,\r\n  Passive,\r\n  PassiveUnmountPendingDev,\r\n  Incomplete,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  HydratingAndUpdate,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanePriority,\r\n  SyncLanePriority,\r\n  SyncBatchedLanePriority,\r\n  InputDiscreteLanePriority,\r\n  DefaultLanePriority,\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  SyncBatchedLane,\r\n  OffscreenLane,\r\n  NoTimestamp,\r\n  findUpdateLane,\r\n  findTransitionLane,\r\n  findRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  hasDiscreteLanes,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  getNextLanes,\r\n  returnNextLanesPriority,\r\n  setCurrentUpdateLanePriority,\r\n  getCurrentUpdateLanePriority,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootExpired,\r\n  markDiscreteUpdatesExpired,\r\n  markRootFinished,\r\n  schedulerPriorityToLanePriority,\r\n  lanePriorityToSchedulerPriority,\r\n} from './ReactFiberLane';\r\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\r\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\r\nimport {completeWork} from './ReactFiberCompleteWork.old';\r\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\r\n  commitLifeCycles as commitLayoutEffectOnFiber,\r\n  commitPlacement,\r\n  commitWork,\r\n  commitDeletion,\r\n  commitDetachRef,\r\n  commitAttachRef,\r\n  commitPassiveEffectDurations,\r\n  commitResetTextContent,\r\n  isSuspenseBoundaryBeingHidden,\r\n} from './ReactFiberCommitWork.old';\r\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\r\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\n\r\nimport {\r\n  recordCommitTime,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentName from 'shared/getComponentName';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {onCommitRoot as onCommitRootDevTools} from './ReactFiberDevToolsHook.old';\r\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\r\n\r\n// Used by `act`\r\nimport enqueueTask from 'shared/enqueueTask';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  IsSomeRendererActing,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b0000000;\r\nconst BatchedContext = /*               */ 0b0000001;\r\nconst EventContext = /*                 */ 0b0000010;\r\nconst DiscreteEventContext = /*         */ 0b0000100;\r\nconst LegacyUnbatchedContext = /*       */ 0b0001000;\r\nconst RenderContext = /*                */ 0b0010000;\r\nconst CommitContext = /*                */ 0b0100000;\r\nexport const RetryAfterError = /*       */ 0b1000000;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst RootIncomplete = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nlet subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n\r\nlet mostRecentlyUpdatedRoot: FiberRoot | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nfunction resetRenderTimer() {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime(): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet nextEffect: Fiber | null = null;\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\n\r\nlet rootsWithPendingDiscreteUpdates: Set<FiberRoot> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\n\r\n// Marks the need to reschedule pending interactions at these lanes\r\n// during the commit phase. This enables them to be traced across components\r\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n// hydration or SuspenseList.\r\n// TODO: Can use a bitmask instead of an array\r\nlet spawnedWorkDuringRender: null | Array<Lane | Lanes> = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventWipLanes: Lanes = NoLanes;\r\nlet currentEventPendingLanes: Lanes = NoLanes;\r\n\r\n// Dev only flag that tracks if passive effects are currently being flushed.\r\n// We warn about state updates for unmounted components differently in this case.\r\nlet isFlushingPassiveEffects = false;\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function getWorkInProgressRoot(): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime() {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime() {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane(fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (expiration time) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n\r\n  // The algorithm for assigning an update to a lane should be stable for all\r\n  // updates at the same priority within the same event. To do this, the inputs\r\n  // to the algorithm must be the same. For example, we use the `renderLanes`\r\n  // to avoid choosing a lane that is already in the middle of rendering.\r\n  //\r\n  // However, the \"included\" lanes could be mutated in between updates in the\r\n  // same event, like if you perform an update inside `flushSync`. Or any other\r\n  // code path that might call `prepareFreshStack`.\r\n  //\r\n  // The trick we use is to cache the first of each of these inputs within an\r\n  // event. Then reset the cached values once we can be sure the event is over.\r\n  // Our heuristic for that is whenever we enter a concurrent work loop.\r\n  //\r\n  // We'll do the same for `currentEventPendingLanes` below.\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (currentEventPendingLanes !== NoLanes) {\r\n      currentEventPendingLanes =\r\n        mostRecentlyUpdatedRoot !== null\r\n          ? mostRecentlyUpdatedRoot.pendingLanes\r\n          : NoLanes;\r\n    }\r\n    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n  }\r\n\r\n  // TODO: Remove this dependency on the Scheduler priority.\r\n  // To do that, we're replacing it with an update lane priority.\r\n  const schedulerPriority = getCurrentPriorityLevel();\r\n\r\n  // The old behavior was using the priority level of the Scheduler.\r\n  // This couples React to the Scheduler internals, so we're replacing it\r\n  // with the currentUpdateLanePriority above. As an example of how this\r\n  // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n  // then we'll get the priority of the current running Scheduler task,\r\n  // which is probably not what we want.\r\n  let lane;\r\n  if (\r\n    // TODO: Temporary. We're removing the concept of discrete updates.\r\n    (executionContext & DiscreteEventContext) !== NoContext &&\r\n    schedulerPriority === UserBlockingSchedulerPriority\r\n  ) {\r\n    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n  } else {\r\n    const schedulerLanePriority = schedulerPriorityToLanePriority(\r\n      schedulerPriority,\r\n    );\r\n\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      // In the new strategy, we will track the current update lane priority\r\n      // inside React and use that priority to select a lane for this update.\r\n      // For now, we're just logging when they're different so we can assess.\r\n      const currentUpdateLanePriority = getCurrentUpdateLanePriority();\r\n\r\n      if (\r\n        schedulerLanePriority !== currentUpdateLanePriority &&\r\n        currentUpdateLanePriority !== NoLanePriority\r\n      ) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Expected current scheduler lane priority %s to match current update lane priority %s',\r\n            schedulerLanePriority,\r\n            currentUpdateLanePriority,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nfunction requestRetryLane(fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & BlockingMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if ((mode & ConcurrentMode) === NoMode) {\r\n    return getCurrentPriorityLevel() === ImmediateSchedulerPriority\r\n      ? (SyncLane: Lane)\r\n      : (SyncBatchedLane: Lane);\r\n  }\r\n\r\n  // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n  if (currentEventWipLanes === NoLanes) {\r\n    currentEventWipLanes = workInProgressRootIncludedLanes;\r\n  }\r\n  return findRetryLane(currentEventWipLanes);\r\n}\r\n\r\nexport function scheduleUpdateOnFiber(\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  checkForNestedUpdates();\r\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  if (root === null) {\r\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n    return null;\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (root === workInProgressRoot) {\r\n    // Received an update to a tree that's in the middle of rendering. Mark\r\n    // that there was an interleaved update work on this root. Unless the\r\n    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n    // phase update. In that case, we don't treat render phase updates as if\r\n    // they were interleaved, for backwards compat reasons.\r\n    if (\r\n      deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext\r\n    ) {\r\n      workInProgressRootUpdatedLanes = mergeLanes(\r\n        workInProgressRootUpdatedLanes,\r\n        lane,\r\n      );\r\n    }\r\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n      // The root already suspended with a delay, which means this render\r\n      // definitely won't finish. Since we have a new update, let's mark it as\r\n      // suspended now, right before marking the incoming update. This has the\r\n      // effect of interrupting the current render and switching to the update.\r\n      // TODO: Make sure this doesn't override pings that happen while we've\r\n      // already started rendering.\r\n      markRootSuspended(root, workInProgressRootRenderLanes);\r\n    }\r\n  }\r\n\r\n  // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n  // priority as an argument to that function and this one.\r\n  const priorityLevel = getCurrentPriorityLevel();\r\n\r\n  if (lane === SyncLane) {\r\n    if (\r\n      // Check if we're inside unbatchedUpdates\r\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\r\n      // Check if we're not already rendering\r\n      (executionContext & (RenderContext | CommitContext)) === NoContext\r\n    ) {\r\n      // Register pending interactions on the root to avoid losing traced interaction data.\r\n      schedulePendingInteractions(root, lane);\r\n\r\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n      // root inside of batchedUpdates should be synchronous, but layout updates\r\n      // should be deferred until the end of the batch.\r\n      performSyncWorkOnRoot(root);\r\n    } else {\r\n      ensureRootIsScheduled(root, eventTime);\r\n      schedulePendingInteractions(root, lane);\r\n      if (executionContext === NoContext) {\r\n        // Flush the synchronous work now, unless we're already working or inside\r\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n        // without immediately flushing it. We only do this for user-initiated\r\n        // updates, to preserve historical behavior of legacy mode.\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    // Schedule a discrete update but only if it's not Sync.\r\n    if (\r\n      (executionContext & DiscreteEventContext) !== NoContext &&\r\n      // Only updates at user-blocking priority or greater are considered\r\n      // discrete, even inside a discrete event.\r\n      (priorityLevel === UserBlockingSchedulerPriority ||\r\n        priorityLevel === ImmediateSchedulerPriority)\r\n    ) {\r\n      // This is the result of a discrete event. Track the lowest priority\r\n      // discrete update per root so we can flush them early, if needed.\r\n      if (rootsWithPendingDiscreteUpdates === null) {\r\n        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n      } else {\r\n        rootsWithPendingDiscreteUpdates.add(root);\r\n      }\r\n    }\r\n    // Schedule other updates after in case the callback is sync.\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, lane);\r\n  }\r\n\r\n  // We use this when assigning a lane for a transition inside\r\n  // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n  // since in the common case of a single root app it probably is. If it's not\r\n  // the same root, then it's not a huge deal, we just might batch more stuff\r\n  // together more than necessary.\r\n  mostRecentlyUpdatedRoot = root;\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\nfunction markUpdateLaneFromFiberToRoot(\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child expiration time.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  // This returns the priority level computed during the `getNextLanes` call.\r\n  const newCallbackPriority = returnNextLanesPriority();\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n      root.callbackNode = null;\r\n      root.callbackPriority = NoLanePriority;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  if (existingCallbackNode !== null) {\r\n    const existingCallbackPriority = root.callbackPriority;\r\n    if (existingCallbackPriority === newCallbackPriority) {\r\n      // The priority hasn't changed. We can reuse the existing task. Exit.\r\n      return;\r\n    }\r\n    // The priority changed. Cancel the existing callback. We'll schedule a new\r\n    // one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLanePriority) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    newCallbackNode = scheduleSyncCallback(\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n    newCallbackNode = scheduleCallback(\r\n      ImmediateSchedulerPriority,\r\n      performSyncWorkOnRoot.bind(null, root),\r\n    );\r\n  } else {\r\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\r\n      newCallbackPriority,\r\n    );\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\nfunction performConcurrentWorkOnRoot(root) {\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventWipLanes = NoLanes;\r\n  currentEventPendingLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next expiration time to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootConcurrent(root, lanes);\r\n\r\n  if (\r\n    includesSomeLane(\r\n      workInProgressRootIncludedLanes,\r\n      workInProgressRootUpdatedLanes,\r\n    )\r\n  ) {\r\n    // The render included lanes that were updated during the render phase.\r\n    // For example, when unhiding a hidden tree, we include all the lanes\r\n    // that were previously skipped when the tree was hidden. That set of\r\n    // lanes is a superset of the lanes we started rendering with.\r\n    //\r\n    // So we'll throw out the current work and restart.\r\n    prepareFreshStack(root, NoLanes);\r\n  } else if (exitStatus !== RootIncomplete) {\r\n    if (exitStatus === RootErrored) {\r\n      executionContext |= RetryAfterError;\r\n\r\n      // If an error occurred during hydration,\r\n      // discard server response and fall back to client side render.\r\n      if (root.hydrate) {\r\n        root.hydrate = false;\r\n        clearContainer(root.containerInfo);\r\n      }\r\n\r\n      // If something threw an error, try rendering one more time. We'll render\r\n      // synchronously to block concurrent data mutations, and we'll includes\r\n      // all pending updates are included. If it still fails after the second\r\n      // attempt, we'll give up and commit the resulting tree.\r\n      lanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (lanes !== NoLanes) {\r\n        exitStatus = renderRootSync(root, lanes);\r\n      }\r\n    }\r\n\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    // We now have a consistent tree. The next step is either to commit it,\r\n    // or, if something suspended, wait to commit it after a timeout.\r\n    const finishedWork: Fiber = (root.current.alternate: any);\r\n    root.finishedWork = finishedWork;\r\n    root.finishedLanes = lanes;\r\n    finishConcurrentRender(root, exitStatus, lanes);\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction finishConcurrentRender(root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootIncomplete:\r\n    case RootFatalErrored: {\r\n      invariant(false, 'Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(null, root),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(root);\r\n      break;\r\n    }\r\n    default: {\r\n      invariant(false, 'Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction markRootSuspended(root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\nfunction performSyncWorkOnRoot(root) {\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  flushPassiveEffects();\r\n\r\n  let lanes;\r\n  let exitStatus;\r\n  if (\r\n    root === workInProgressRoot &&\r\n    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)\r\n  ) {\r\n    // There's a partial tree, and at least one of its lanes has expired. Finish\r\n    // rendering it before rendering the rest of the expired work.\r\n    lanes = workInProgressRootRenderLanes;\r\n    exitStatus = renderRootSync(root, lanes);\r\n    if (\r\n      includesSomeLane(\r\n        workInProgressRootIncludedLanes,\r\n        workInProgressRootUpdatedLanes,\r\n      )\r\n    ) {\r\n      // The render included lanes that were updated during the render phase.\r\n      // For example, when unhiding a hidden tree, we include all the lanes\r\n      // that were previously skipped when the tree was hidden. That set of\r\n      // lanes is a superset of the lanes we started rendering with.\r\n      //\r\n      // Note that this only happens when part of the tree is rendered\r\n      // concurrently. If the whole tree is rendered synchronously, then there\r\n      // are no interleaved events.\r\n      lanes = getNextLanes(root, lanes);\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  } else {\r\n    lanes = getNextLanes(root, NoLanes);\r\n    exitStatus = renderRootSync(root, lanes);\r\n  }\r\n\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    executionContext |= RetryAfterError;\r\n\r\n    // If an error occurred during hydration,\r\n    // discard server response and fall back to client side render.\r\n    if (root.hydrate) {\r\n      root.hydrate = false;\r\n      clearContainer(root.containerInfo);\r\n    }\r\n\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (lanes !== NoLanes) {\r\n      exitStatus = renderRootSync(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n  commitRoot(root);\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\r\n  markRootExpired(root, lanes);\r\n  ensureRootIsScheduled(root, now());\r\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n    resetRenderTimer();\r\n    flushSyncCallbackQueue();\r\n  }\r\n}\r\n\r\nexport function getExecutionContext(): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function flushDiscreteUpdates() {\r\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n  // as a public API.\r\n  if (\r\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\r\n    NoContext\r\n  ) {\r\n    if (__DEV__) {\r\n      if ((executionContext & RenderContext) !== NoContext) {\r\n        console.error(\r\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\r\n            'already rendering.',\r\n        );\r\n      }\r\n    }\r\n    // We're already rendering, so we can't synchronously flush pending work.\r\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n    // like `el.focus()`. Exit.\r\n    return;\r\n  }\r\n  flushPendingDiscreteUpdates();\r\n  // If the discrete updates scheduled passive effects, flush them now so that\r\n  // they fire before the next serial event.\r\n  flushPassiveEffects();\r\n}\r\n\r\nexport function deferredUpdates<A>(fn: () => A): A {\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(DefaultLanePriority);\r\n      return runWithPriority(NormalSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    return runWithPriority(NormalSchedulerPriority, fn);\r\n  }\r\n}\r\n\r\nfunction flushPendingDiscreteUpdates() {\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    // For each root with pending discrete updates, schedule a callback to\r\n    // immediately flush them.\r\n    const roots = rootsWithPendingDiscreteUpdates;\r\n    rootsWithPendingDiscreteUpdates = null;\r\n    roots.forEach(root => {\r\n      markDiscreteUpdatesExpired(root);\r\n      ensureRootIsScheduled(root, now());\r\n    });\r\n  }\r\n  // Now flush the immediate queue.\r\n  flushSyncCallbackQueue();\r\n}\r\n\r\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= EventContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R>(\r\n  fn: (A, B, C) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= DiscreteEventContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(InputDiscreteLanePriority);\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      return runWithPriority(\r\n        UserBlockingSchedulerPriority,\r\n        fn.bind(null, a, b, c, d),\r\n      );\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext &= ~BatchedContext;\r\n  executionContext |= LegacyUnbatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushSync<A, R>(fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        'flushSync was called from inside a lifecycle method. React cannot ' +\r\n          'flush when React is already rendering. Consider moving this call to ' +\r\n          'a scheduler task or micro task.',\r\n      );\r\n    }\r\n    return fn(a);\r\n  }\r\n  executionContext |= BatchedContext;\r\n\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  } else {\r\n    try {\r\n      if (fn) {\r\n        return runWithPriority(ImmediateSchedulerPriority, fn.bind(null, a));\r\n      } else {\r\n        return (undefined: $FlowFixMe);\r\n      }\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      // Flush the immediate callbacks that were scheduled during this batch.\r\n      // Note that this will happen even if batchedUpdates is higher up\r\n      // the stack.\r\n      flushSyncCallbackQueue();\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushControlled(fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  if (decoupleUpdatePriorityFromScheduler) {\r\n    const previousLanePriority = getCurrentUpdateLanePriority();\r\n    try {\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  } else {\r\n    try {\r\n      runWithPriority(ImmediateSchedulerPriority, fn);\r\n    } finally {\r\n      executionContext = prevExecutionContext;\r\n      if (executionContext === NoContext) {\r\n        // Flush the immediate callbacks that were scheduled during this batch\r\n        resetRenderTimer();\r\n        flushSyncCallbackQueue();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes(fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      unwindInterruptedWork(interruptedWork);\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  workInProgress = createWorkInProgress(root.current, null);\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootIncomplete;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n\r\n  if (enableSchedulerTracing) {\r\n    spawnedWorkDuringRender = null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n}\r\n\r\nfunction handleError(root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher() {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher(prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nfunction pushInteractions(root) {\r\n  if (enableSchedulerTracing) {\r\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\r\n    __interactionsRef.current = root.memoizedInteractions;\r\n    return prevInteractions;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction popInteractions(prevInteractions) {\r\n  if (enableSchedulerTracing) {\r\n    __interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nexport function markCommitTimeOfFallback() {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend(): void {\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible(): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootIncomplete ||\r\n    workInProgressRootExitStatus === RootSuspended\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError() {\r\n  if (workInProgressRootExitStatus !== RootCompleted) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet(): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootIncomplete;\r\n}\r\n\r\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    invariant(\r\n      false,\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n        'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync() {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n    startWorkOnPendingInteractions(root, lanes);\r\n  }\r\n\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n  }\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootIncomplete;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent() {\r\n  // Perform work until Scheduler asks us to yield\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      resetChildLanes(completedWork);\r\n\r\n      if (\r\n        returnFiber !== null &&\r\n        // Do not append effects to parents if a sibling failed to complete\r\n        (returnFiber.flags & Incomplete) === NoFlags\r\n      ) {\r\n        // Append all the effects of the subtree and this fiber onto the effect\r\n        // list of the parent. The completion order of the children affects the\r\n        // side-effect order.\r\n        if (returnFiber.firstEffect === null) {\r\n          returnFiber.firstEffect = completedWork.firstEffect;\r\n        }\r\n        if (completedWork.lastEffect !== null) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n          }\r\n          returnFiber.lastEffect = completedWork.lastEffect;\r\n        }\r\n\r\n        // If this fiber had side-effects, we append it AFTER the children's\r\n        // side-effects. We can perform certain side-effects earlier if needed,\r\n        // by doing multiple passes over the effect list. We don't want to\r\n        // schedule our own side-effect on our own list because if end up\r\n        // reusing children we'll schedule this effect onto itself since we're\r\n        // at the end.\r\n        const flags = completedWork.flags;\r\n\r\n        // Skip both NoWork and PerformedWork tags when creating the effect\r\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n        // committed.\r\n        if (flags > PerformedWork) {\r\n          if (returnFiber.lastEffect !== null) {\r\n            returnFiber.lastEffect.nextEffect = completedWork;\r\n          } else {\r\n            returnFiber.firstEffect = completedWork;\r\n          }\r\n          returnFiber.lastEffect = completedWork;\r\n        }\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its expiration time.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its effect list.\r\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n        returnFiber.flags |= Incomplete;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootIncomplete) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction resetChildLanes(completedWork: Fiber) {\r\n  if (\r\n    // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n    // to switch statement in `completeWork`.\r\n    (completedWork.tag === LegacyHiddenComponent ||\r\n      completedWork.tag === OffscreenComponent) &&\r\n    completedWork.memoizedState !== null &&\r\n    !includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) &&\r\n    (completedWork.mode & ConcurrentMode) !== NoLanes\r\n  ) {\r\n    // The children of this component are hidden. Don't bubble their\r\n    // expiration times.\r\n    return;\r\n  }\r\n\r\n  let newChildLanes = NoLanes;\r\n\r\n  // Bubble up the earliest expiration time.\r\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n    // In profiling mode, resetChildExpirationTime is also used to reset\r\n    // profiler durations.\r\n    let actualDuration = completedWork.actualDuration;\r\n    let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n    // When work is done, it should bubble to the parent's actualDuration. If\r\n    // the fiber has not been cloned though, (meaning no work was done), then\r\n    // this value will reflect the amount of time spent working on a previous\r\n    // render. In that case it should not bubble. We determine whether it was\r\n    // cloned by comparing the child pointer.\r\n    const shouldBubbleActualDurations =\r\n      completedWork.alternate === null ||\r\n      completedWork.child !== completedWork.alternate.child;\r\n\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      if (shouldBubbleActualDurations) {\r\n        actualDuration += child.actualDuration;\r\n      }\r\n      treeBaseDuration += child.treeBaseDuration;\r\n      child = child.sibling;\r\n    }\r\n\r\n    const isTimedOutSuspense =\r\n      completedWork.tag === SuspenseComponent &&\r\n      completedWork.memoizedState !== null;\r\n    if (isTimedOutSuspense) {\r\n      // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n      const primaryChildFragment = completedWork.child;\r\n      if (primaryChildFragment !== null) {\r\n        treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n      }\r\n    }\r\n\r\n    completedWork.actualDuration = actualDuration;\r\n    completedWork.treeBaseDuration = treeBaseDuration;\r\n  } else {\r\n    let child = completedWork.child;\r\n    while (child !== null) {\r\n      newChildLanes = mergeLanes(\r\n        newChildLanes,\r\n        mergeLanes(child.lanes, child.childLanes),\r\n      );\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n}\r\n\r\nfunction commitRoot(root) {\r\n  const renderPriorityLevel = getCurrentPriorityLevel();\r\n  runWithPriority(\r\n    ImmediateSchedulerPriority,\r\n    commitRootImpl.bind(null, root, renderPriorityLevel),\r\n  );\r\n  return null;\r\n}\r\n\r\nfunction commitRootImpl(root, renderPriorityLevel) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Should not already be working.',\r\n  );\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  }\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  invariant(\r\n    finishedWork !== root.current,\r\n    'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n  );\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  root.callbackNode = null;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // Clear already finished discrete updates in case that a later call of\r\n  // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n  // a scheduled timeout.\r\n  if (rootsWithPendingDiscreteUpdates !== null) {\r\n    if (\r\n      !hasDiscreteLanes(remainingLanes) &&\r\n      rootsWithPendingDiscreteUpdates.has(root)\r\n    ) {\r\n      rootsWithPendingDiscreteUpdates.delete(root);\r\n    }\r\n  }\r\n\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // Get the list of effects.\r\n  let firstEffect;\r\n  if (finishedWork.flags > PerformedWork) {\r\n    // A fiber's effect list consists only of its children, not itself. So if\r\n    // the root has an effect, we need to add it to the end of the list. The\r\n    // resulting list is the set that would belong to the root's parent, if it\r\n    // had one; that is, all the effects in the tree including the root.\r\n    if (finishedWork.lastEffect !== null) {\r\n      finishedWork.lastEffect.nextEffect = finishedWork;\r\n      firstEffect = finishedWork.firstEffect;\r\n    } else {\r\n      firstEffect = finishedWork;\r\n    }\r\n  } else {\r\n    // There is no effect on the root.\r\n    firstEffect = finishedWork.firstEffect;\r\n  }\r\n\r\n  if (firstEffect !== null) {\r\n    let previousLanePriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      previousLanePriority = getCurrentUpdateLanePriority();\r\n      setCurrentUpdateLanePriority(SyncLanePriority);\r\n    }\r\n\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n    const prevInteractions = pushInteractions(root);\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n    focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n    shouldFireAfterActiveInstanceBlur = false;\r\n\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitBeforeMutationEffects();\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    // We no longer need to track the active instance fiber\r\n    focusedInstanceHandle = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(\r\n          null,\r\n          commitMutationEffects,\r\n          null,\r\n          root,\r\n          renderPriorityLevel,\r\n        );\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitMutationEffects(root, renderPriorityLevel);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    if (shouldFireAfterActiveInstanceBlur) {\r\n      afterActiveInstanceBlur();\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    nextEffect = firstEffect;\r\n    do {\r\n      if (__DEV__) {\r\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n        if (hasCaughtError()) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      } else {\r\n        try {\r\n          commitLayoutEffects(root, lanes);\r\n        } catch (error) {\r\n          invariant(nextEffect !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(nextEffect, error);\r\n          nextEffect = nextEffect.nextEffect;\r\n        }\r\n      }\r\n    } while (nextEffect !== null);\r\n\r\n    nextEffect = null;\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    if (enableSchedulerTracing) {\r\n      popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    }\r\n    executionContext = prevExecutionContext;\r\n\r\n    if (decoupleUpdatePriorityFromScheduler && previousLanePriority != null) {\r\n      // Reset the priority to the previous non-sync value.\r\n      setCurrentUpdateLanePriority(previousLanePriority);\r\n    }\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n  } else {\r\n    // We are done with the effect chain at this point so let's clear the\r\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n    // clear this in flushPassiveEffects.\r\n    nextEffect = firstEffect;\r\n    while (nextEffect !== null) {\r\n      const nextNextEffect = nextEffect.nextEffect;\r\n      nextEffect.nextEffect = null;\r\n      if (nextEffect.flags & Deletion) {\r\n        detachFiberAfterEffects(nextEffect);\r\n      }\r\n      nextEffect = nextNextEffect;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  if (remainingLanes !== NoLanes) {\r\n    if (enableSchedulerTracing) {\r\n      if (spawnedWorkDuringRender !== null) {\r\n        const expirationTimes = spawnedWorkDuringRender;\r\n        spawnedWorkDuringRender = null;\r\n        for (let i = 0; i < expirationTimes.length; i++) {\r\n          scheduleInteractions(\r\n            root,\r\n            expirationTimes[i],\r\n            root.memoizedInteractions,\r\n          );\r\n        }\r\n      }\r\n      schedulePendingInteractions(root, remainingLanes);\r\n    }\r\n  } else {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      // If there are no passive effects, then we can complete the pending interactions.\r\n      // Otherwise, we'll wait until after the passive effects are flushed.\r\n      // Wait to do this until after remaining work has been scheduled,\r\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n      finishPendingInteractions(root, lanes);\r\n    }\r\n  }\r\n\r\n  if (remainingLanes === SyncLane) {\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    // This is a legacy edge case. We just committed the initial mount of\r\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n    // synchronously, but layout updates should be deferred until the end\r\n    // of the batch.\r\n    return null;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbackQueue();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction commitBeforeMutationEffects() {\r\n  while (nextEffect !== null) {\r\n    const current = nextEffect.alternate;\r\n\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      } else {\r\n        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n        if (\r\n          nextEffect.tag === SuspenseComponent &&\r\n          isSuspenseBoundaryBeingHidden(current, nextEffect) &&\r\n          doesFiberContain(nextEffect, focusedInstanceHandle)\r\n        ) {\r\n          shouldFireAfterActiveInstanceBlur = true;\r\n          beforeActiveInstanceBlur();\r\n        }\r\n      }\r\n    }\r\n\r\n    const flags = nextEffect.flags;\r\n    if ((flags & Snapshot) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\r\n\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n    if ((flags & Passive) !== NoFlags) {\r\n      // If there are passive effects, schedule a callback to flush at\r\n      // the earliest opportunity.\r\n      if (!rootDoesHavePassiveEffects) {\r\n        rootDoesHavePassiveEffects = true;\r\n        scheduleCallback(NormalSchedulerPriority, () => {\r\n          flushPassiveEffects();\r\n          return null;\r\n        });\r\n      }\r\n    }\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitMutationEffects(\r\n  root: FiberRoot,\r\n  renderPriorityLevel: ReactPriorityLevel,\r\n) {\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & ContentReset) {\r\n      commitResetTextContent(nextEffect);\r\n    }\r\n\r\n    if (flags & Ref) {\r\n      const current = nextEffect.alternate;\r\n      if (current !== null) {\r\n        commitDetachRef(current);\r\n      }\r\n      if (enableScopeAPI) {\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (nextEffect.tag === ScopeComponent) {\r\n          commitAttachRef(nextEffect);\r\n        }\r\n      }\r\n    }\r\n\r\n    // The following switch statement is only concerned about placement,\r\n    // updates, and deletions. To avoid needing to add a case for every possible\r\n    // bitmap value, we remove the secondary effects from the effect tag and\r\n    // switch on that value.\r\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n    switch (primaryFlags) {\r\n      case Placement: {\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n        // and isMounted is deprecated anyway so we should be able to kill this.\r\n        nextEffect.flags &= ~Placement;\r\n        break;\r\n      }\r\n      case PlacementAndUpdate: {\r\n        // Placement\r\n        commitPlacement(nextEffect);\r\n        // Clear the \"placement\" from effect tag so that we know that this is\r\n        // inserted, before any life-cycles like componentDidMount gets called.\r\n        nextEffect.flags &= ~Placement;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Hydrating: {\r\n        nextEffect.flags &= ~Hydrating;\r\n        break;\r\n      }\r\n      case HydratingAndUpdate: {\r\n        nextEffect.flags &= ~Hydrating;\r\n\r\n        // Update\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Update: {\r\n        const current = nextEffect.alternate;\r\n        commitWork(current, nextEffect);\r\n        break;\r\n      }\r\n      case Deletion: {\r\n        commitDeletion(root, nextEffect, renderPriorityLevel);\r\n        break;\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStarted(committedLanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStarted(committedLanes);\r\n  }\r\n\r\n  // TODO: Should probably move the bulk of this function to commitWork.\r\n  while (nextEffect !== null) {\r\n    setCurrentDebugFiberInDEV(nextEffect);\r\n\r\n    const flags = nextEffect.flags;\r\n\r\n    if (flags & (Update | Callback)) {\r\n      const current = nextEffect.alternate;\r\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\r\n    }\r\n\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (flags & Ref && nextEffect.tag !== ScopeComponent) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    } else {\r\n      if (flags & Ref) {\r\n        commitAttachRef(nextEffect);\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n    nextEffect = nextEffect.nextEffect;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logLayoutEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markLayoutEffectsStopped();\r\n  }\r\n}\r\n\r\nexport function flushPassiveEffects(): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\r\n    const priorityLevel =\r\n      pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\r\n        ? NormalSchedulerPriority\r\n        : pendingPassiveEffectsRenderPriority;\r\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority;\r\n    if (decoupleUpdatePriorityFromScheduler) {\r\n      const previousLanePriority = getCurrentUpdateLanePriority();\r\n      try {\r\n        setCurrentUpdateLanePriority(\r\n          schedulerPriorityToLanePriority(priorityLevel),\r\n        );\r\n        return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n      } finally {\r\n        setCurrentUpdateLanePriority(previousLanePriority);\r\n      }\r\n    } else {\r\n      return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectMount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsMount.push(effect, fiber);\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nexport function enqueuePendingPassiveHookEffectUnmount(\r\n  fiber: Fiber,\r\n  effect: HookEffect,\r\n): void {\r\n  pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n  if (__DEV__) {\r\n    fiber.flags |= PassiveUnmountPendingDev;\r\n    const alternate = fiber.alternate;\r\n    if (alternate !== null) {\r\n      alternate.flags |= PassiveUnmountPendingDev;\r\n    }\r\n  }\r\n  if (!rootDoesHavePassiveEffects) {\r\n    rootDoesHavePassiveEffects = true;\r\n    scheduleCallback(NormalSchedulerPriority, () => {\r\n      flushPassiveEffects();\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\r\n  const create = effect.create;\r\n  effect.destroy = create();\r\n}\r\n\r\nfunction flushPassiveEffectsImpl() {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  invariant(\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\r\n    'Cannot flush passive effects while already rendering.',\r\n  );\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n  const prevInteractions = pushInteractions(root);\r\n\r\n  // It's important that ALL pending passive effect destroy functions are called\r\n  // before ANY passive effect create functions are called.\r\n  // Otherwise effects in sibling components might interfere with each other.\r\n  // e.g. a destroy function in one component may unintentionally override a ref\r\n  // value set by a create function in another component.\r\n  // Layout effects have the same constraint.\r\n\r\n  // First pass: Destroy stale passive effects.\r\n  const unmountEffects = pendingPassiveHookEffectsUnmount;\r\n  pendingPassiveHookEffectsUnmount = [];\r\n  for (let i = 0; i < unmountEffects.length; i += 2) {\r\n    const effect = ((unmountEffects[i]: any): HookEffect);\r\n    const fiber = ((unmountEffects[i + 1]: any): Fiber);\r\n    const destroy = effect.destroy;\r\n    effect.destroy = undefined;\r\n\r\n    if (__DEV__) {\r\n      fiber.flags &= ~PassiveUnmountPendingDev;\r\n      const alternate = fiber.alternate;\r\n      if (alternate !== null) {\r\n        alternate.flags &= ~PassiveUnmountPendingDev;\r\n      }\r\n    }\r\n\r\n    if (typeof destroy === 'function') {\r\n      if (__DEV__) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          startPassiveEffectTimer();\r\n          invokeGuardedCallback(null, destroy, null);\r\n          recordPassiveEffectDuration(fiber);\r\n        } else {\r\n          invokeGuardedCallback(null, destroy, null);\r\n        }\r\n        if (hasCaughtError()) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          const error = clearCaughtError();\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n        resetCurrentDebugFiberInDEV();\r\n      } else {\r\n        try {\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            fiber.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startPassiveEffectTimer();\r\n              destroy();\r\n            } finally {\r\n              recordPassiveEffectDuration(fiber);\r\n            }\r\n          } else {\r\n            destroy();\r\n          }\r\n        } catch (error) {\r\n          invariant(fiber !== null, 'Should be working on an effect.');\r\n          captureCommitPhaseError(fiber, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Second pass: Create new passive effects.\r\n  const mountEffects = pendingPassiveHookEffectsMount;\r\n  pendingPassiveHookEffectsMount = [];\r\n  for (let i = 0; i < mountEffects.length; i += 2) {\r\n    const effect = ((mountEffects[i]: any): HookEffect);\r\n    const fiber = ((mountEffects[i + 1]: any): Fiber);\r\n    if (__DEV__) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        fiber.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n        recordPassiveEffectDuration(fiber);\r\n      } else {\r\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\r\n      }\r\n      if (hasCaughtError()) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        const error = clearCaughtError();\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    } else {\r\n      try {\r\n        const create = effect.create;\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startPassiveEffectTimer();\r\n            effect.destroy = create();\r\n          } finally {\r\n            recordPassiveEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          effect.destroy = create();\r\n        }\r\n      } catch (error) {\r\n        invariant(fiber !== null, 'Should be working on an effect.');\r\n        captureCommitPhaseError(fiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Note: This currently assumes there are no passive effects on the root fiber\r\n  // because the root is not part of its own effect list.\r\n  // This could change in the future.\r\n  let effect = root.current.firstEffect;\r\n  while (effect !== null) {\r\n    const nextNextEffect = effect.nextEffect;\r\n    // Remove nextEffect pointer to assist GC\r\n    effect.nextEffect = null;\r\n    if (effect.flags & Deletion) {\r\n      detachFiberAfterEffects(effect);\r\n    }\r\n    effect = nextNextEffect;\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulerTracing) {\r\n    popInteractions(((prevInteractions: any): Set<Interaction>));\r\n    finishPendingInteractions(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbackQueue();\r\n\r\n  // If additional passive effects were scheduled, increment a counter. If this\r\n  // exceeds the limit, we'll fire a warning.\r\n  nestedPassiveUpdateCount =\r\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError(error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot(\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update);\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, SyncLane);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = sourceFiber.return;\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update);\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n          schedulePendingInteractions(root, SyncLane);\r\n        } else {\r\n          // This component has already been unmounted.\r\n          // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n          // but we can still call the log-only boundary so the error isn't swallowed.\r\n          //\r\n          // TODO This is only a temporary bandaid for the old reconciler fork.\r\n          // We can delete this special case once the new fork is merged.\r\n          if (\r\n            typeof instance.componentDidCatch === 'function' &&\r\n            !isAlreadyFailedLegacyErrorBoundary(instance)\r\n          ) {\r\n            try {\r\n              instance.componentDidCatch(error, errorInfo);\r\n            } catch (errorToIgnore) {\r\n              // TODO Ignore this error? Rethrow it?\r\n              // This is kind of an edge case.\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot(\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n  schedulePendingInteractions(root, pingedLanes);\r\n}\r\n\r\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new expiration time.\r\n  if (retryLane === NoLane) {\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n    schedulePendingInteractions(root, retryLane);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  if (enableSuspenseServerRenderer) {\r\n    switch (boundaryFiber.tag) {\r\n      case SuspenseComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n        if (suspenseState !== null) {\r\n          retryLane = suspenseState.retryLane;\r\n        }\r\n        break;\r\n      case SuspenseListComponent:\r\n        retryCache = boundaryFiber.stateNode;\r\n        break;\r\n      default:\r\n        invariant(\r\n          false,\r\n          'Pinged unknown suspense boundary type. ' +\r\n            'This is probably a bug in React.',\r\n        );\r\n    }\r\n  } else {\r\n    retryCache = boundaryFiber.stateNode;\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd(timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n    ? 480\r\n    : timeElapsed < 1080\r\n    ? 1080\r\n    : timeElapsed < 1920\r\n    ? 1920\r\n    : timeElapsed < 3000\r\n    ? 3000\r\n    : timeElapsed < 4320\r\n    ? 4320\r\n    : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates() {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n    invariant(\r\n      false,\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n        'repeatedly calls setState inside componentWillUpdate or ' +\r\n        'componentDidUpdate. React limits the number of nested updates to ' +\r\n        'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n          'have a dependency array, or one of the dependencies changes on ' +\r\n          'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n          'This indicates that you have a side-effect in your render function that ' +\r\n          'asynchronously later calls tries to update the component. Move this work to ' +\r\n          'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n  if (__DEV__) {\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent &&\r\n      tag !== Block\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // If there are pending passive effects unmounts for this Fiber,\r\n    // we can assume that they would have prevented this update.\r\n    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    if (isFlushingPassiveEffects) {\r\n      // Do not warn if we are currently flushing passive effects!\r\n      //\r\n      // React can't directly detect a memory leak, but there are some clues that warn about one.\r\n      // One of these clues is when an unmounted React component tries to update its state.\r\n      // For example, if a component forgets to remove an event listener when unmounting,\r\n      // that listener may be called later and try to update state,\r\n      // at which point React would warn about the potential leak.\r\n      //\r\n      // Warning signals are the most useful when they're strong.\r\n      // (So we should avoid false positive warnings.)\r\n      // Updating state from within an effect cleanup function is sometimes a necessary pattern, e.g.:\r\n      // 1. Updating an ancestor that a component had registered itself with on mount.\r\n      // 2. Resetting state when a component is hidden after going offscreen.\r\n    } else {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"Can't perform a React state update on an unmounted component. This \" +\r\n            'is a no-op, but it indicates a memory leak in your application. To ' +\r\n            'fix, cancel all subscriptions and asynchronous tasks in %s.',\r\n          tag === ClassComponent\r\n            ? 'the componentWillUnmount method'\r\n            : 'a useEffect cleanup function',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(unitOfWork);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n        // Rethrow this error instead of the original one.\r\n        throw replayError;\r\n      } else {\r\n        // This branch is reachable if the render phase is impure.\r\n        throw originalError;\r\n      }\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      (executionContext & RenderContext) !== NoContext &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentName(workInProgress.type)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentName(fiber.type) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n                'within `render`). Render methods should be a pure ' +\r\n                'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// a 'shared' variable that changes when act() opens/closes in tests.\r\nexport const IsThisRendererActing = {current: (false: boolean)};\r\n\r\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      IsSomeRendererActing.current === true &&\r\n      IsThisRendererActing.current !== true\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          \"It looks like you're using the wrong act() around your test interactions.\\n\" +\r\n            'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\r\n            '// for react-dom:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import {act} fr' +\r\n            \"om 'react-dom/test-utils';\\n\" +\r\n            '// ...\\n' +\r\n            'act(() => ...);\\n\\n' +\r\n            '// for react-test-renderer:\\n' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'import TestRenderer fr' +\r\n            \"om react-test-renderer';\\n\" +\r\n            'const {act} = TestRenderer;\\n' +\r\n            '// ...\\n' +\r\n            'act(() => ...);',\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      (fiber.mode & StrictMode) !== NoMode &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      console.error(\r\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n        getComponentName(fiber.type),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (\r\n      warnsIfNotActing === true &&\r\n      executionContext === NoContext &&\r\n      IsSomeRendererActing.current === false &&\r\n      IsThisRendererActing.current === false\r\n    ) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n            'When testing, code that causes React state updates should be ' +\r\n            'wrapped into act(...):\\n\\n' +\r\n            'act(() => {\\n' +\r\n            '  /* fire events that update state */\\n' +\r\n            '});\\n' +\r\n            '/* assert on the output */\\n\\n' +\r\n            \"This ensures that you're testing the behavior the user would see \" +\r\n            'in the browser.' +\r\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentName(fiber.type),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\r\n\r\n// In tests, we want to enforce a mocked scheduler.\r\nlet didWarnAboutUnmockedScheduler = false;\r\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n// scheduler is the actual recommendation. The alternative could be a testing build,\r\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n// to get their tests right.\r\n\r\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      didWarnAboutUnmockedScheduler === false &&\r\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\r\n    ) {\r\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      } else if (warnAboutUnmockedScheduler === true) {\r\n        didWarnAboutUnmockedScheduler = true;\r\n        console.error(\r\n          'Starting from React v18, the \"scheduler\" module will need to be mocked ' +\r\n            'to guarantee consistent behaviour across tests and browsers. ' +\r\n            'For example, with jest: \\n' +\r\n            // Break up requires to avoid accidentally parsing them as dependencies.\r\n            \"jest.mock('scheduler', () => require\" +\r\n            \"('scheduler/unstable_mock'));\\n\\n\" +\r\n            'For more info, visit https://reactjs.org/link/mock-scheduler',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeThreadID(root: FiberRoot, lane: Lane | Lanes) {\r\n  // Interaction threads are unique per root and expiration time.\r\n  // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n  // and it represents a batch of work. Could make a helper function instead,\r\n  // but meh this is fine for now.\r\n  return (lane: any) * 1000 + root.interactionThreadID;\r\n}\r\n\r\nexport function markSpawnedWork(lane: Lane | Lanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n  if (spawnedWorkDuringRender === null) {\r\n    spawnedWorkDuringRender = [lane];\r\n  } else {\r\n    spawnedWorkDuringRender.push(lane);\r\n  }\r\n}\r\n\r\nfunction scheduleInteractions(\r\n  root: FiberRoot,\r\n  lane: Lane | Lanes,\r\n  interactions: Set<Interaction>,\r\n) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  if (interactions.size > 0) {\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    const pendingInteractions = pendingInteractionMap.get(lane);\r\n    if (pendingInteractions != null) {\r\n      interactions.forEach(interaction => {\r\n        if (!pendingInteractions.has(interaction)) {\r\n          // Update the pending async work count for previously unscheduled interaction.\r\n          interaction.__count++;\r\n        }\r\n\r\n        pendingInteractions.add(interaction);\r\n      });\r\n    } else {\r\n      pendingInteractionMap.set(lane, new Set(interactions));\r\n\r\n      // Update the pending async work count for the current interactions.\r\n      interactions.forEach(interaction => {\r\n        interaction.__count++;\r\n      });\r\n    }\r\n\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lane);\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    }\r\n  }\r\n}\r\n\r\nfunction schedulePendingInteractions(root: FiberRoot, lane: Lane | Lanes) {\r\n  // This is called when work is scheduled on a root.\r\n  // It associates the current interactions with the newly-scheduled expiration.\r\n  // They will be restored when that expiration is later committed.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  scheduleInteractions(root, lane, __interactionsRef.current);\r\n}\r\n\r\nfunction startWorkOnPendingInteractions(root: FiberRoot, lanes: Lanes) {\r\n  // This is called when new work is started on a root.\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  // Determine which interactions this batch of work currently includes, So that\r\n  // we can accurately attribute time spent working on it, And so that cascading\r\n  // work triggered during the render phase will be associated with it.\r\n  const interactions: Set<Interaction> = new Set();\r\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledLane) => {\r\n    if (includesSomeLane(lanes, scheduledLane)) {\r\n      scheduledInteractions.forEach(interaction =>\r\n        interactions.add(interaction),\r\n      );\r\n    }\r\n  });\r\n\r\n  // Store the current set of interactions on the FiberRoot for a few reasons:\r\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n  // without having to recalculate it. We will also use it in commitWork() to\r\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n  // way to access it when the onCommitRoot() hook is called.\r\n  root.memoizedInteractions = interactions;\r\n\r\n  if (interactions.size > 0) {\r\n    const subscriber = __subscriberRef.current;\r\n    if (subscriber !== null) {\r\n      const threadID = computeThreadID(root, lanes);\r\n      try {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      } catch (error) {\r\n        // If the subscriber throws, rethrow it in a separate task\r\n        scheduleCallback(ImmediateSchedulerPriority, () => {\r\n          throw error;\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishPendingInteractions(root, committedLanes) {\r\n  if (!enableSchedulerTracing) {\r\n    return;\r\n  }\r\n\r\n  const remainingLanesAfterCommit = root.pendingLanes;\r\n\r\n  let subscriber;\r\n\r\n  try {\r\n    subscriber = __subscriberRef.current;\r\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n      // FIXME: More than one lane can finish in a single commit.\r\n      const threadID = computeThreadID(root, committedLanes);\r\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n    }\r\n  } catch (error) {\r\n    // If the subscriber throws, rethrow it in a separate task\r\n    scheduleCallback(ImmediateSchedulerPriority, () => {\r\n      throw error;\r\n    });\r\n  } finally {\r\n    // Clear completed interactions from the pending Map.\r\n    // Unless the render was suspended or cascading work was scheduled,\r\n    // In which case– leave pending interactions until the subsequent render.\r\n    const pendingInteractionMap = root.pendingInteractionMap;\r\n    pendingInteractionMap.forEach((scheduledInteractions, lane) => {\r\n      // Only decrement the pending interaction count if we're done.\r\n      // If there's still work at the current priority,\r\n      // That indicates that we are waiting for suspense data.\r\n      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n        pendingInteractionMap.delete(lane);\r\n\r\n        scheduledInteractions.forEach(interaction => {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            try {\r\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n            } catch (error) {\r\n              // If the subscriber throws, rethrow it in a separate task\r\n              scheduleCallback(ImmediateSchedulerPriority, () => {\r\n                throw error;\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// `act` testing API\r\n//\r\n// TODO: This is mostly a copy-paste from the legacy `act`, which does not have\r\n// access to the same internals that we do here. Some trade offs in the\r\n// implementation no longer make sense.\r\n\r\nlet isFlushingAct = false;\r\nlet isInsideThisAct = false;\r\n\r\nfunction shouldForceFlushFallbacksInDEV() {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && actingUpdatesScopeDepth > 0;\r\n}\r\n\r\nconst flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;\r\nconst isSchedulerMocked = typeof flushMockScheduler === 'function';\r\n\r\n// Returns whether additional work was scheduled. Caller should keep flushing\r\n// until there's no work left.\r\nfunction flushActWork(): boolean {\r\n  if (flushMockScheduler !== undefined) {\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      return flushMockScheduler();\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  } else {\r\n    // No mock scheduler available. However, the only type of pending work is\r\n    // passive effects, which we control. So we can flush that.\r\n    const prevIsFlushing = isFlushingAct;\r\n    isFlushingAct = true;\r\n    try {\r\n      let didFlushWork = false;\r\n      while (flushPassiveEffects()) {\r\n        didFlushWork = true;\r\n      }\r\n      return didFlushWork;\r\n    } finally {\r\n      isFlushingAct = prevIsFlushing;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\r\n  try {\r\n    flushActWork();\r\n    enqueueTask(() => {\r\n      if (flushActWork()) {\r\n        flushWorkAndMicroTasks(onDone);\r\n      } else {\r\n        onDone();\r\n      }\r\n    });\r\n  } catch (err) {\r\n    onDone(err);\r\n  }\r\n}\r\n\r\n// we track the 'depth' of the act() calls with this counter,\r\n// so we can tell if any async act() calls try to run in parallel.\r\n\r\nlet actingUpdatesScopeDepth = 0;\r\nlet didWarnAboutUsingActInProd = false;\r\n\r\nexport function act(callback: () => Thenable<mixed>): Thenable<void> {\r\n  if (!__DEV__) {\r\n    if (didWarnAboutUsingActInProd === false) {\r\n      didWarnAboutUsingActInProd = true;\r\n      // eslint-disable-next-line react-internal/no-production-logging\r\n      console.error(\r\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\r\n  actingUpdatesScopeDepth++;\r\n\r\n  const previousIsSomeRendererActing = IsSomeRendererActing.current;\r\n  const previousIsThisRendererActing = IsThisRendererActing.current;\r\n  const previousIsInsideThisAct = isInsideThisAct;\r\n  IsSomeRendererActing.current = true;\r\n  IsThisRendererActing.current = true;\r\n  isInsideThisAct = true;\r\n\r\n  function onDone() {\r\n    actingUpdatesScopeDepth--;\r\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\r\n    IsThisRendererActing.current = previousIsThisRendererActing;\r\n    isInsideThisAct = previousIsInsideThisAct;\r\n    if (__DEV__) {\r\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\r\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\r\n        console.error(\r\n          'You seem to have overlapping act() calls, this is not supported. ' +\r\n            'Be sure to await previous act() calls before making a new one. ',\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let result;\r\n  try {\r\n    result = batchedUpdates(callback);\r\n  } catch (error) {\r\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\r\n    onDone();\r\n    throw error;\r\n  }\r\n\r\n  if (\r\n    result !== null &&\r\n    typeof result === 'object' &&\r\n    typeof result.then === 'function'\r\n  ) {\r\n    // setup a boolean that gets set to true only\r\n    // once this act() call is await-ed\r\n    let called = false;\r\n    if (__DEV__) {\r\n      if (typeof Promise !== 'undefined') {\r\n        //eslint-disable-next-line no-undef\r\n        Promise.resolve()\r\n          .then(() => {})\r\n          .then(() => {\r\n            if (called === false) {\r\n              console.error(\r\n                'You called act(async () => ...) without await. ' +\r\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\r\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\r\n              );\r\n            }\r\n          });\r\n      }\r\n    }\r\n\r\n    // in the async case, the returned thenable runs the callback, flushes\r\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\r\n    // and cleans up\r\n    return {\r\n      then(resolve, reject) {\r\n        called = true;\r\n        result.then(\r\n          () => {\r\n            if (\r\n              actingUpdatesScopeDepth > 1 ||\r\n              (isSchedulerMocked === true &&\r\n                previousIsSomeRendererActing === true)\r\n            ) {\r\n              onDone();\r\n              resolve();\r\n              return;\r\n            }\r\n            // we're about to exit the act() scope,\r\n            // now's the time to flush tasks/effects\r\n            flushWorkAndMicroTasks((err: ?Error) => {\r\n              onDone();\r\n              if (err) {\r\n                reject(err);\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n          },\r\n          err => {\r\n            onDone();\r\n            reject(err);\r\n          },\r\n        );\r\n      },\r\n    };\r\n  } else {\r\n    if (__DEV__) {\r\n      if (result !== undefined) {\r\n        console.error(\r\n          'The callback passed to act(...) function ' +\r\n            'must return undefined, or a Promise. You returned %s',\r\n          result,\r\n        );\r\n      }\r\n    }\r\n\r\n    // flush effects until none remain, and cleanup\r\n    try {\r\n      if (\r\n        actingUpdatesScopeDepth === 1 &&\r\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\r\n      ) {\r\n        // we're about to exit the act() scope,\r\n        // now's the time to flush effects\r\n        flushActWork();\r\n      }\r\n      onDone();\r\n    } catch (err) {\r\n      onDone();\r\n      throw err;\r\n    }\r\n\r\n    // in the sync case, the returned thenable only warns *if* await-ed\r\n    return {\r\n      then(resolve) {\r\n        if (__DEV__) {\r\n          console.error(\r\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\r\n          );\r\n        }\r\n        resolve();\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber): void {\r\n  fiber.sibling = null;\r\n  fiber.stateNode = null;\r\n}\r\n"
    }
  ]
}